"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkapp"] = self["webpackChunkapp"] || []).push([["index"],{

/***/ "./libs/dependingStateRouter/src/DSNavigatorActions.ts":
/*!*************************************************************!*\
  !*** ./libs/dependingStateRouter/src/DSNavigatorActions.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"navigatorBuilder\": () => (/* binding */ navigatorBuilder),\n/* harmony export */   \"navigatorSetLocation\": () => (/* binding */ navigatorSetLocation)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n\r\nconst navigatorBuilder = (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.storeBuilder)(\"navigator\");\r\nconst navigatorSetLocation = navigatorBuilder.createAction(\"setLocation\");\r\n\n\n//# sourceURL=webpack://app/./libs/dependingStateRouter/src/DSNavigatorActions.ts?");

/***/ }),

/***/ "./libs/dependingStateRouter/src/DSNavigatorStore.ts":
/*!***********************************************************!*\
  !*** ./libs/dependingStateRouter/src/DSNavigatorStore.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSNavigatorStore\": () => (/* binding */ DSNavigatorStore)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n/* harmony import */ var _matchPath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matchPath */ \"./libs/dependingStateRouter/src/matchPath.ts\");\n/* harmony import */ var _DSNavigatorActions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DSNavigatorActions */ \"./libs/dependingStateRouter/src/DSNavigatorActions.ts\");\n\r\n\r\n\r\nclass DSNavigatorStore extends dependingState__WEBPACK_IMPORTED_MODULE_0__.DSObjectStore {\r\n    constructor(storeName, stateValue, configuration) {\r\n        super(storeName, stateValue, configuration);\r\n        _DSNavigatorActions__WEBPACK_IMPORTED_MODULE_2__.navigatorBuilder.bindValueStore(this);\r\n    }\r\n    setRouter(routerStore) {\r\n        this.routerStore = routerStore;\r\n    }\r\n    matchPath(pathname, options) {\r\n        const result = (0,_matchPath__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(pathname, options);\r\n        if (result !== null) {\r\n            dependingState__WEBPACK_IMPORTED_MODULE_0__.dsLog.debugACME(\"DS\", \"DSNavigatorStore\", \"matchPath\", (pathname || \"\"));\r\n        }\r\n        return result;\r\n    }\r\n    initializeStore() {\r\n        super.initializeStore();\r\n        if (this.routerStore === undefined) {\r\n            this.routerStore = this.storeManager.getValueStore(\"router\");\r\n        }\r\n        if (this.routerStore === undefined) {\r\n            throw new Error(\"router store not found\");\r\n        }\r\n        else {\r\n            this.routerStore.listenEventLocationChanged(this.storeName, (e) => {\r\n                try {\r\n                    dependingState__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSNavigatorStore\", \"handleLocationChanged\", e.payload.location.pathname);\r\n                    const p = this.handleLocationChanged(e.payload);\r\n                    if (p && typeof p.then === \"function\") {\r\n                        return (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.catchLog)(\"handleLocationChanged\", p);\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    dependingState__WEBPACK_IMPORTED_MODULE_0__.dsLog.errorACME(\"DS\", \"DSNavigatorStore\", \"handleLocationChanged-failed\", err);\r\n                }\r\n            });\r\n            _DSNavigatorActions__WEBPACK_IMPORTED_MODULE_2__.navigatorSetLocation.listenEvent(\"setLocation\", (e) => {\r\n                try {\r\n                    dependingState__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSNavigatorStore\", \"handleSetLocation\", e.payload.page);\r\n                    const p = this.handleSetLocation(e.payload);\r\n                    if (p && typeof p.then === \"function\") {\r\n                        return (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.catchLog)(\"handleSetLocation\", p);\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    dependingState__WEBPACK_IMPORTED_MODULE_0__.dsLog.errorACME(\"DS\", \"DSNavigatorStore\", \"handleSetLocation-failed\", err);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * called if push or replace was called\r\n     * @param payload\r\n     * @example\r\n     *  const {action ,location, updateMode } = payload;\r\n     *  {\r\n     *      const m = this.matchPath(path:string, route:RouteDefinition);\r\n     *      if (m) {\r\n     *          m.params[\"dtStart\"]\r\n     *      }\r\n     *  }\r\n    */\r\n    handleLocationChanged(payload) {\r\n        /*\r\n        const {action ,location, updateMode } = payload;\r\n        {\r\n            const m = this.matchPath(path:string, route:RouteDefinition);\r\n            if (m) {\r\n                m.params[\"dtStart\"]\r\n            }\r\n        }\r\n        */\r\n    }\r\n    /**\r\n     * called from the code to navigate\r\n     * @param payload\r\n     */\r\n    handleSetLocation(payload) {\r\n        if (payload.to === undefined) {\r\n            payload = this.convertTo(payload);\r\n        }\r\n        //payload.page\r\n        //payload.pathArguments\r\n        const stateValuePC = (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.getPropertiesChanged)(this.stateValue);\r\n        stateValuePC.setIf(\"page\", payload.page);\r\n        stateValuePC.setIf(\"pathArguments\", payload.pathArguments, dependingState__WEBPACK_IMPORTED_MODULE_0__.deepEquals);\r\n        // // TODO thinkof can we get rid of this?\r\n        // stateValuePC.setIf(\"to\", payload.to, deepEquals);\r\n        // stateValuePC.setIf(\"pathPattern\", payload.pathPattern || \"\");\r\n        // stateValuePC.setIf(\"isExact\", payload.isExact || false);\r\n        stateValuePC.valueChangedIfNeeded(\"handleSetLocation\");\r\n        if (payload.to !== undefined) {\r\n            this.routerStore.setLocationFromNavigator(payload.to);\r\n        }\r\n        if (payload.eventToProcess) {\r\n            return this.storeManager.emitEvent(payload.eventToProcess);\r\n        }\r\n    }\r\n    /**\r\n     * converts pathName and pathArguments to to\r\n     * @param payload\r\n     * @returns modified payload or a new copy\r\n     */\r\n    convertTo(payload) {\r\n        return payload;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingStateRouter/src/DSNavigatorStore.ts?");

/***/ }),

/***/ "./libs/dependingStateRouter/src/DSNavigatorWithRoutesAction.ts":
/*!**********************************************************************!*\
  !*** ./libs/dependingStateRouter/src/DSNavigatorWithRoutesAction.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"navigatorWithRoutesBuilder\": () => (/* binding */ navigatorWithRoutesBuilder)\n/* harmony export */ });\n/* harmony import */ var _DSNavigatorActions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DSNavigatorActions */ \"./libs/dependingStateRouter/src/DSNavigatorActions.ts\");\n// import {\r\n//     DSEvent,\r\n//     storeBuilder,\r\n// } from 'dependingState';\r\n\r\n// import type { NavigatorSetLocationPayload } from './types';\r\nconst navigatorWithRoutesBuilder = _DSNavigatorActions__WEBPACK_IMPORTED_MODULE_0__.navigatorBuilder;\r\n// export const navigatorSetLocation = navigatorBuilder.createAction<NavigatorSetLocationPayload, \"setLocation\">(\"setLocation\");\r\n// export type NavigatorChangePageEvent = DSEvent<NavigatorSetLocationPayload, \"setLocation\", \"navigator\">;\r\n\n\n//# sourceURL=webpack://app/./libs/dependingStateRouter/src/DSNavigatorWithRoutesAction.ts?");

/***/ }),

/***/ "./libs/dependingStateRouter/src/DSNavigatorWithRoutesStore.ts":
/*!*********************************************************************!*\
  !*** ./libs/dependingStateRouter/src/DSNavigatorWithRoutesStore.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSNavigatorWithRoutesStore\": () => (/* binding */ DSNavigatorWithRoutesStore)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n/* harmony import */ var _DSNavigatorStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DSNavigatorStore */ \"./libs/dependingStateRouter/src/DSNavigatorStore.ts\");\n\r\n\r\nclass DSNavigatorWithRoutesStore extends _DSNavigatorStore__WEBPACK_IMPORTED_MODULE_1__.DSNavigatorStore {\r\n    constructor(pageNames, pageRouteNotFound, routes, storeName, stateValue, configuration) {\r\n        super(storeName, stateValue, configuration);\r\n        // already done in super: navigatorWithRoutesBuilder.bindValueStore(this);\r\n        this.pageNames = pageNames;\r\n        this.pageRouteNotFound = pageRouteNotFound;\r\n        this.routes = routes;\r\n    }\r\n    matchPaths(location) {\r\n        for (const pageName of this.pageNames) {\r\n            const m = this.matchPath(location.pathname, this.routes[pageName]);\r\n            if (m) {\r\n                return [pageName, m];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /** called if push or replace was called */\r\n    handleLocationChanged(payload) {\r\n        const { action, location, updateMode } = payload;\r\n        {\r\n            const result = this.matchPaths(location);\r\n            if (result !== null) {\r\n                const { pageName, pathArguments } = this.convertPageParameters(result[0], result[1], action, location, updateMode);\r\n                this.setPagePathArguments(pageName, pathArguments);\r\n            }\r\n            else {\r\n                this.setPagePathArguments(this.pageRouteNotFound, {});\r\n            }\r\n        }\r\n    }\r\n    setPagePathArguments(pageName, pathArguments) {\r\n        const pc = (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.getPropertiesChanged)(this.stateValue);\r\n        this.stateValue.value.pathArguments;\r\n        pc.setIf(\"page\", pageName);\r\n        pc.setIf(\"pathArguments\", pathArguments, dependingState__WEBPACK_IMPORTED_MODULE_0__.deepEquals);\r\n        pc.valueChangedIfNeeded(\"handleLocationChanged\");\r\n    }\r\n    convertPageParameters(pageName, m, action, location, updateMode) {\r\n        return { pageName, pathArguments: m.params };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingStateRouter/src/DSNavigatorWithRoutesStore.ts?");

/***/ }),

/***/ "./libs/dependingStateRouter/src/DSRouterAction.ts":
/*!*********************************************************!*\
  !*** ./libs/dependingStateRouter/src/DSRouterAction.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dsRouterBuilder\": () => (/* binding */ dsRouterBuilder),\n/* harmony export */   \"routerLocationChanged\": () => (/* binding */ routerLocationChanged),\n/* harmony export */   \"routerPush\": () => (/* binding */ routerPush),\n/* harmony export */   \"routerReplace\": () => (/* binding */ routerReplace)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n\r\nconst dsRouterBuilder = (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.storeBuilder)(\"router\");\r\nconst routerPush = dsRouterBuilder.createAction(\"push\");\r\nconst routerReplace = dsRouterBuilder.createAction(\"replace\");\r\nconst routerLocationChanged = dsRouterBuilder.createAction(\"locationChanged\");\r\n\n\n//# sourceURL=webpack://app/./libs/dependingStateRouter/src/DSRouterAction.ts?");

/***/ }),

/***/ "./libs/dependingStateRouter/src/DSRouterStore.ts":
/*!********************************************************!*\
  !*** ./libs/dependingStateRouter/src/DSRouterStore.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSRouterStore\": () => (/* binding */ DSRouterStore),\n/* harmony export */   \"getRouterValueInitial\": () => (/* binding */ getRouterValueInitial)\n/* harmony export */ });\n/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./history */ \"./libs/dependingStateRouter/src/history.ts\");\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n/* harmony import */ var _injectQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./injectQuery */ \"./libs/dependingStateRouter/src/injectQuery.ts\");\n/* harmony import */ var _DSRouterAction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DSRouterAction */ \"./libs/dependingStateRouter/src/DSRouterAction.ts\");\n\r\n\r\n\r\n\r\n\r\nfunction noop() { }\r\n// Define the initial state using that type\r\nfunction getRouterValueInitial() {\r\n    const result = {\r\n        location: {\r\n            pathname: window.location.pathname,\r\n            search: window.location.search,\r\n            state: null,\r\n            hash: window.location.hash,\r\n            query: {},\r\n            key: \"\"\r\n        },\r\n        action: \"PUSH\",\r\n        updateMode: _history__WEBPACK_IMPORTED_MODULE_0__.UpdateMode.Initialization\r\n    };\r\n    return result;\r\n}\r\nclass DSRouterStore extends dependingState__WEBPACK_IMPORTED_MODULE_1__.DSObjectStore {\r\n    constructor(history, stateValue, configuration) {\r\n        super(\"router\", stateValue, configuration);\r\n        this.history = history;\r\n        this.historyUnlisten = noop;\r\n        this.suspressNavigator = false;\r\n        _DSRouterAction__WEBPACK_IMPORTED_MODULE_3__.dsRouterBuilder.bindValueStore(this);\r\n    }\r\n    initializeStore() {\r\n        _DSRouterAction__WEBPACK_IMPORTED_MODULE_3__.routerPush.listenEvent(\"router/push\", (e) => {\r\n            const location = e.payload;\r\n            if (e.payload.noListener === true) {\r\n                this.suspressNavigator = true;\r\n            }\r\n            this.history.push(location.to, location.state, location.updateMode ?? _history__WEBPACK_IMPORTED_MODULE_0__.UpdateMode.FromCode, false);\r\n        });\r\n        _DSRouterAction__WEBPACK_IMPORTED_MODULE_3__.routerReplace.listenEvent(\"router/replace\", (e) => {\r\n            const location = e.payload;\r\n            if (e.payload.noListener === true) {\r\n                this.suspressNavigator = true;\r\n            }\r\n            this.history.replace(location.to, location.state, location.updateMode ?? _history__WEBPACK_IMPORTED_MODULE_0__.UpdateMode.FromCode, false);\r\n        });\r\n    }\r\n    initializeBoot() {\r\n        this.subscribe();\r\n    }\r\n    setLocationFromNavigator(to) {\r\n        let locationTo;\r\n        if (typeof to === \"string\") {\r\n            locationTo = new URL(to, window.location.href);\r\n        }\r\n        else if (typeof to === \"object\") {\r\n            locationTo = {\r\n                pathname: \"\",\r\n                search: \"\",\r\n                hash: \"\",\r\n                ...to\r\n            };\r\n        }\r\n        else {\r\n            // don't know what to do\r\n            return;\r\n        }\r\n        const currentLocation = this.stateValue.value.location;\r\n        if (((currentLocation.pathname || \"\") === (locationTo.pathname || \"\"))\r\n            && ((currentLocation.search || \"\") === (locationTo.search || \"\"))\r\n            && ((currentLocation.hash || \"\") === (locationTo.hash || \"\"))) {\r\n            // skip href modification\r\n        }\r\n        else {\r\n            this.suspressNavigator = true;\r\n            this.history.push(to, undefined, _history__WEBPACK_IMPORTED_MODULE_0__.UpdateMode.FromCode, false);\r\n        }\r\n    }\r\n    listenEventLocationChanged(msg, callback) {\r\n        return this.listenEvent(msg, \"locationChanged\", callback);\r\n    }\r\n    historyListener(update) {\r\n        //console.warn(\"historyListener\", this.suspressNavigator, update);\r\n        const suspressNavigator = this.suspressNavigator;\r\n        this.suspressNavigator = false;\r\n        const locationPC = (0,dependingState__WEBPACK_IMPORTED_MODULE_1__.getPropertiesChanged)(this.stateValue);\r\n        locationPC.setIf(\"action\", update.action || \"PUSH\");\r\n        locationPC.setIf(\"location\", (0,_injectQuery__WEBPACK_IMPORTED_MODULE_2__.injectQuery)(update.location));\r\n        locationPC.setIf(\"updateMode\", update.updateMode);\r\n        locationPC.valueChangedIfNeeded(\"historyListener\");\r\n        if (suspressNavigator) {\r\n            // may be changed but ignore it\r\n            dependingState__WEBPACK_IMPORTED_MODULE_1__.dsLog.debugACME(\"DS\", \"DSRouterStore\", \"historyListener\", update.location.pathname, \"suspressNavigator\");\r\n        }\r\n        else {\r\n            const p = _DSRouterAction__WEBPACK_IMPORTED_MODULE_3__.routerLocationChanged.emitEvent(this.stateValue.value);\r\n            if (p && typeof p.then === \"function\") {\r\n                return (0,dependingState__WEBPACK_IMPORTED_MODULE_1__.catchLog)(\"routerLocationChanged\", p);\r\n            }\r\n        }\r\n    }\r\n    subscribe() {\r\n        this.unsubscribe();\r\n        this.historyUnlisten = this.history.listen(this.historyListener.bind(this));\r\n        this.historyListener({ location: this.history.location, action: this.history.action, updateMode: _history__WEBPACK_IMPORTED_MODULE_0__.UpdateMode.Initialization });\r\n    }\r\n    unsubscribe() {\r\n        this.historyUnlisten();\r\n        this.historyUnlisten = () => { };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingStateRouter/src/DSRouterStore.ts?");

/***/ }),

/***/ "./libs/dependingStateRouter/src/DSRouterValue.ts":
/*!********************************************************!*\
  !*** ./libs/dependingStateRouter/src/DSRouterValue.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSRouterValue\": () => (/* binding */ DSRouterValue),\n/* harmony export */   \"getDSRouterValueInitial\": () => (/* binding */ getDSRouterValueInitial)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n/* harmony import */ var _DSRouterStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DSRouterStore */ \"./libs/dependingStateRouter/src/DSRouterStore.ts\");\n\r\n\r\nclass DSRouterValue extends dependingState__WEBPACK_IMPORTED_MODULE_0__.DSStateValueSelf {\r\n    constructor(action, location, updateMode) {\r\n        super();\r\n        this.action = action;\r\n        this.location = location;\r\n        this.updateMode = updateMode;\r\n    }\r\n}\r\nfunction getDSRouterValueInitial() {\r\n    const { action, location, updateMode } = (0,_DSRouterStore__WEBPACK_IMPORTED_MODULE_1__.getRouterValueInitial)();\r\n    const result = new DSRouterValue(action, location, updateMode);\r\n    return result;\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingStateRouter/src/DSRouterValue.ts?");

/***/ }),

/***/ "./libs/dependingStateRouter/src/history.ts":
/*!**************************************************!*\
  !*** ./libs/dependingStateRouter/src/history.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Action\": () => (/* binding */ Action),\n/* harmony export */   \"UpdateMode\": () => (/* binding */ UpdateMode),\n/* harmony export */   \"createBrowserHistory\": () => (/* binding */ createBrowserHistory),\n/* harmony export */   \"createHashHistory\": () => (/* binding */ createHashHistory),\n/* harmony export */   \"createMemoryHistory\": () => (/* binding */ createMemoryHistory),\n/* harmony export */   \"createPath\": () => (/* binding */ createPath),\n/* harmony export */   \"parsePath\": () => (/* binding */ parsePath)\n/* harmony export */ });\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/ReactTraining/history/tree/master/docs/api-reference.md#action\r\n */\r\nvar Action;\r\n(function (Action) {\r\n    /**\r\n     * A POP indicates a change to an arbitrary index in the history stack, such\r\n     * as a back or forward navigation. It does not describe the direction of the\r\n     * navigation, only that the current index changed.\r\n     *\r\n     * Note: This is the default action for newly created history objects.\r\n     */\r\n    Action[\"Pop\"] = \"POP\";\r\n    /**\r\n     * A PUSH indicates a new entry being added to the history stack, such as when\r\n     * a link is clicked and a new page loads. When this happens, all subsequent\r\n     * entries in the stack are lost.\r\n     */\r\n    Action[\"Push\"] = \"PUSH\";\r\n    /**\r\n     * A REPLACE indicates the entry at the current index in the history stack\r\n     * being replaced by a new one.\r\n     */\r\n    Action[\"Replace\"] = \"REPLACE\";\r\n})(Action || (Action = {}));\r\nvar UpdateMode;\r\n(function (UpdateMode) {\r\n    UpdateMode[UpdateMode[\"FromBrowser\"] = 0] = \"FromBrowser\";\r\n    UpdateMode[UpdateMode[\"FromCode\"] = 1] = \"FromCode\";\r\n    UpdateMode[UpdateMode[\"Initialization\"] = 2] = \"Initialization\";\r\n})(UpdateMode || (UpdateMode = {}));\r\nconst readOnly = (typeof Object.freeze === \"function\")\r\n    ? obj => Object.freeze(obj)\r\n    : obj => obj;\r\nfunction warning(cond, message) {\r\n    if (!cond) {\r\n        // eslint-disable-next-line no-console\r\n        if (typeof console !== 'undefined')\r\n            console.warn(message);\r\n        try {\r\n            // Welcome to debugging history!\r\n            //\r\n            // This error is thrown as a convenience so you can more easily\r\n            // find the source for a warning that appears in the console by\r\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\r\n            throw new Error(message);\r\n            // eslint-disable-next-line no-empty\r\n        }\r\n        catch (e) { }\r\n    }\r\n}\r\nconst BeforeUnloadEventType = 'beforeunload';\r\nconst HashChangeEventType = 'hashchange';\r\nconst PopStateEventType = 'popstate';\r\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/ReactTraining/history/tree/master/docs/api-reference.md#createbrowserhistory\r\n */\r\nfunction createBrowserHistory(options = {}) {\r\n    let { window = document.defaultView } = options;\r\n    let globalHistory = window.history;\r\n    function getIndexAndLocation() {\r\n        let { pathname, search, hash } = window.location;\r\n        let state = globalHistory.state || {};\r\n        return [\r\n            state.idx,\r\n            readOnly({\r\n                pathname,\r\n                search,\r\n                hash,\r\n                state: state.usr || null,\r\n                key: state.key || 'default'\r\n            })\r\n        ];\r\n    }\r\n    let blockedPopTx = null;\r\n    function handlePop() {\r\n        if (blockedPopTx) {\r\n            blockers.call(blockedPopTx);\r\n            blockedPopTx = null;\r\n        }\r\n        else {\r\n            let nextAction = Action.Pop;\r\n            let [nextIndex, nextLocation] = getIndexAndLocation();\r\n            if (blockers.length) {\r\n                if (nextIndex != null) {\r\n                    let delta = index - nextIndex;\r\n                    if (delta) {\r\n                        // Revert the POP\r\n                        blockedPopTx = {\r\n                            action: nextAction,\r\n                            location: nextLocation,\r\n                            updateMode: UpdateMode.FromBrowser,\r\n                            retry() {\r\n                                go(delta * -1);\r\n                            }\r\n                        };\r\n                        go(delta);\r\n                    }\r\n                }\r\n                else {\r\n                    // Trying to POP to a location with no index. We did not create\r\n                    // this location, so we can't effectively block the navigation.\r\n                    warning(false, \r\n                    // TODO: Write up a doc that explains our blocking strategy in\r\n                    // detail and link to it here so people can understand better what\r\n                    // is going on and how to avoid it.\r\n                    `You are trying to block a POP navigation to a location that was not ` +\r\n                        `created by the history library. The block will fail silently in ` +\r\n                        `production, but in general you should do all navigation with the ` +\r\n                        `history library (instead of using window.history.pushState directly) ` +\r\n                        `to avoid this situation.`);\r\n                }\r\n            }\r\n            else {\r\n                applyTx(nextAction, UpdateMode.FromBrowser);\r\n            }\r\n        }\r\n    }\r\n    window.addEventListener(PopStateEventType, handlePop);\r\n    let action = Action.Pop;\r\n    let [index, location] = getIndexAndLocation();\r\n    let listeners = createEvents();\r\n    let blockers = createEvents();\r\n    if (index == null) {\r\n        index = 0;\r\n        globalHistory.replaceState({ ...globalHistory.state, idx: index }, '');\r\n    }\r\n    function createHref(to) {\r\n        return typeof to === 'string' ? to : createPath(to);\r\n    }\r\n    function getNextLocation(to, state = null) {\r\n        return readOnly({\r\n            ...location,\r\n            ...(typeof to === 'string' ? parsePath(to) : to),\r\n            state,\r\n            key: createKey()\r\n        });\r\n    }\r\n    function getHistoryStateAndUrl(nextLocation, index) {\r\n        return [\r\n            {\r\n                usr: nextLocation.state,\r\n                key: nextLocation.key,\r\n                idx: index\r\n            },\r\n            createHref(nextLocation)\r\n        ];\r\n    }\r\n    function allowTx(action, location, retry) {\r\n        return (!blockers.length || (blockers.call({ action, location, retry }), false));\r\n    }\r\n    function applyTx(nextAction, updateMode) {\r\n        action = nextAction;\r\n        [index, location] = getIndexAndLocation();\r\n        listeners.call({ action, location, updateMode });\r\n    }\r\n    function push(to, state, updateMode, noListener) {\r\n        let nextAction = Action.Push;\r\n        let nextLocation = getNextLocation(to, state);\r\n        function retry() {\r\n            push(to, state);\r\n        }\r\n        if (allowTx(nextAction, nextLocation, retry)) {\r\n            let [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\r\n            // TODO: Support forced reloading\r\n            // try...catch because iOS limits us to 100 pushState calls :/\r\n            try {\r\n                globalHistory.pushState(historyState, '', url);\r\n            }\r\n            catch (error) {\r\n                // They are going to lose state here, but there is no real\r\n                // way to warn them about it since the page will refresh...\r\n                window.location.assign(url);\r\n            }\r\n            if (noListener === true) {\r\n                // \r\n            }\r\n            else {\r\n                applyTx(nextAction, (updateMode === undefined) ? UpdateMode.FromCode : updateMode);\r\n            }\r\n        }\r\n    }\r\n    function replace(to, state, updateMode, noListener) {\r\n        let nextAction = Action.Replace;\r\n        let nextLocation = getNextLocation(to, state);\r\n        function retry() {\r\n            replace(to, state);\r\n        }\r\n        if (allowTx(nextAction, nextLocation, retry)) {\r\n            let [historyState, url] = getHistoryStateAndUrl(nextLocation, index);\r\n            // TODO: Support forced reloading\r\n            globalHistory.replaceState(historyState, '', url);\r\n            if (noListener === true) {\r\n                // \r\n            }\r\n            else {\r\n                applyTx(nextAction, (updateMode === undefined) ? UpdateMode.FromCode : updateMode);\r\n            }\r\n        }\r\n    }\r\n    function go(delta) {\r\n        globalHistory.go(delta);\r\n    }\r\n    let history = {\r\n        get action() {\r\n            return action;\r\n        },\r\n        get location() {\r\n            return location;\r\n        },\r\n        createHref,\r\n        push,\r\n        replace,\r\n        go,\r\n        back() {\r\n            go(-1);\r\n        },\r\n        forward() {\r\n            go(1);\r\n        },\r\n        listen(listener) {\r\n            return listeners.push(listener);\r\n        },\r\n        block(blocker) {\r\n            let unblock = blockers.push(blocker);\r\n            if (blockers.length === 1) {\r\n                window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\r\n            }\r\n            return function () {\r\n                unblock();\r\n                // Remove the beforeunload listener so the document may\r\n                // still be salvageable in the pagehide event.\r\n                // See https://html.spec.whatwg.org/#unloading-documents\r\n                if (!blockers.length) {\r\n                    window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\r\n                }\r\n            };\r\n        }\r\n    };\r\n    return history;\r\n}\r\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/ReactTraining/history/tree/master/docs/api-reference.md#createhashhistory\r\n */\r\nfunction createHashHistory(options = {}) {\r\n    let { window = document.defaultView } = options;\r\n    let globalHistory = window.history;\r\n    function getIndexAndLocation() {\r\n        let { pathname = '/', search = '', hash = '' } = parsePath(window.location.hash.substring(1));\r\n        let state = globalHistory.state || {};\r\n        return [\r\n            state.idx,\r\n            readOnly({\r\n                pathname,\r\n                search,\r\n                hash,\r\n                state: state.usr || null,\r\n                key: state.key || 'default'\r\n            })\r\n        ];\r\n    }\r\n    let blockedPopTx = null;\r\n    function handlePop() {\r\n        if (blockedPopTx) {\r\n            blockers.call(blockedPopTx);\r\n            blockedPopTx = null;\r\n        }\r\n        else {\r\n            let nextAction = Action.Pop;\r\n            let [nextIndex, nextLocation] = getIndexAndLocation();\r\n            if (blockers.length) {\r\n                if (nextIndex != null) {\r\n                    let delta = index - nextIndex;\r\n                    if (delta) {\r\n                        // Revert the POP\r\n                        blockedPopTx = {\r\n                            action: nextAction,\r\n                            location: nextLocation,\r\n                            updateMode: UpdateMode.FromBrowser,\r\n                            retry() {\r\n                                go(delta * -1);\r\n                            }\r\n                        };\r\n                        go(delta);\r\n                    }\r\n                }\r\n                else {\r\n                    // Trying to POP to a location with no index. We did not create\r\n                    // this location, so we can't effectively block the navigation.\r\n                    warning(false, \r\n                    // TODO: Write up a doc that explains our blocking strategy in\r\n                    // detail and link to it here so people can understand better\r\n                    // what is going on and how to avoid it.\r\n                    `You are trying to block a POP navigation to a location that was not ` +\r\n                        `created by the history library. The block will fail silently in ` +\r\n                        `production, but in general you should do all navigation with the ` +\r\n                        `history library (instead of using window.history.pushState directly) ` +\r\n                        `to avoid this situation.`);\r\n                }\r\n            }\r\n            else {\r\n                applyTx(nextAction, UpdateMode.FromBrowser);\r\n            }\r\n        }\r\n    }\r\n    window.addEventListener(PopStateEventType, handlePop);\r\n    // popstate does not fire on hashchange in IE 11 and old (trident) Edge\r\n    // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\r\n    window.addEventListener(HashChangeEventType, () => {\r\n        let [, nextLocation] = getIndexAndLocation();\r\n        // Ignore extraneous hashchange events.\r\n        if (createPath(nextLocation) !== createPath(location)) {\r\n            handlePop();\r\n        }\r\n    });\r\n    let action = Action.Pop;\r\n    let [index, location] = getIndexAndLocation();\r\n    let listeners = createEvents();\r\n    let blockers = createEvents();\r\n    if (index == null) {\r\n        index = 0;\r\n        globalHistory.replaceState({ ...globalHistory.state, idx: index }, '');\r\n    }\r\n    function getBaseHref() {\r\n        let base = document.querySelector('base');\r\n        let href = '';\r\n        if (base && base.getAttribute('href')) {\r\n            let url = window.location.href;\r\n            let hashIndex = url.indexOf('#');\r\n            href = hashIndex === -1 ? url : url.slice(0, hashIndex);\r\n        }\r\n        return href;\r\n    }\r\n    function createHref(to) {\r\n        return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\r\n    }\r\n    function getNextLocation(to, state = null) {\r\n        return readOnly({\r\n            ...location,\r\n            ...(typeof to === 'string' ? parsePath(to) : to),\r\n            state,\r\n            key: createKey()\r\n        });\r\n    }\r\n    function getHistoryStateAndUrl(nextLocation, index) {\r\n        return [\r\n            {\r\n                usr: nextLocation.state,\r\n                key: nextLocation.key,\r\n                idx: index\r\n            },\r\n            createHref(nextLocation)\r\n        ];\r\n    }\r\n    function allowTx(action, location, retry) {\r\n        return (!blockers.length || (blockers.call({ action, location, retry }), false));\r\n    }\r\n    function applyTx(nextAction, updateMode) {\r\n        action = nextAction;\r\n        [index, location] = getIndexAndLocation();\r\n        listeners.call({ action, location, updateMode });\r\n    }\r\n    function push(to, state, updateMode, noListener) {\r\n        let nextAction = Action.Push;\r\n        let nextLocation = getNextLocation(to, state);\r\n        function retry() {\r\n            push(to, state);\r\n        }\r\n        warning(nextLocation.pathname.charAt(0) === '/', `Relative pathnames are not supported in hash history.push(${JSON.stringify(to)})`);\r\n        if (allowTx(nextAction, nextLocation, retry)) {\r\n            let [historyState, url] = getHistoryStateAndUrl(nextLocation, index + 1);\r\n            // TODO: Support forced reloading\r\n            // try...catch because iOS limits us to 100 pushState calls :/\r\n            try {\r\n                globalHistory.pushState(historyState, '', url);\r\n            }\r\n            catch (error) {\r\n                // They are going to lose state here, but there is no real\r\n                // way to warn them about it since the page will refresh...\r\n                window.location.assign(url);\r\n            }\r\n            if (noListener === true) {\r\n                // \r\n            }\r\n            else {\r\n                applyTx(nextAction, (updateMode === undefined) ? UpdateMode.FromCode : updateMode);\r\n            }\r\n        }\r\n    }\r\n    function replace(to, state, updateMode, noListener) {\r\n        let nextAction = Action.Replace;\r\n        let nextLocation = getNextLocation(to, state);\r\n        function retry() {\r\n            replace(to, state);\r\n        }\r\n        warning(nextLocation.pathname.charAt(0) === '/', `Relative pathnames are not supported in hash history.replace(${JSON.stringify(to)})`);\r\n        if (allowTx(nextAction, nextLocation, retry)) {\r\n            let [historyState, url] = getHistoryStateAndUrl(nextLocation, index);\r\n            // TODO: Support forced reloading\r\n            globalHistory.replaceState(historyState, '', url);\r\n            applyTx(nextAction, (updateMode === undefined) ? UpdateMode.FromCode : updateMode);\r\n        }\r\n    }\r\n    function go(delta) {\r\n        globalHistory.go(delta);\r\n    }\r\n    let history = {\r\n        get action() {\r\n            return action;\r\n        },\r\n        get location() {\r\n            return location;\r\n        },\r\n        createHref,\r\n        push,\r\n        replace,\r\n        go,\r\n        back() {\r\n            go(-1);\r\n        },\r\n        forward() {\r\n            go(1);\r\n        },\r\n        listen(listener) {\r\n            return listeners.push(listener);\r\n        },\r\n        block(blocker) {\r\n            let unblock = blockers.push(blocker);\r\n            if (blockers.length === 1) {\r\n                window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\r\n            }\r\n            return function () {\r\n                unblock();\r\n                // Remove the beforeunload listener so the document may\r\n                // still be salvageable in the pagehide event.\r\n                // See https://html.spec.whatwg.org/#unloading-documents\r\n                if (!blockers.length) {\r\n                    window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\r\n                }\r\n            };\r\n        }\r\n    };\r\n    return history;\r\n}\r\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/ReactTraining/history/tree/master/docs/api-reference.md#creatememoryhistory\r\n */\r\nfunction createMemoryHistory(options = {}) {\r\n    let { initialEntries = ['/'], initialIndex } = options;\r\n    let entries = initialEntries.map(entry => {\r\n        let location = readOnly({\r\n            pathname: '/',\r\n            search: '',\r\n            hash: '',\r\n            state: null,\r\n            key: createKey(),\r\n            ...(typeof entry === 'string' ? parsePath(entry) : entry)\r\n        });\r\n        warning(location.pathname.charAt(0) === '/', `Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: ${JSON.stringify(entry)})`);\r\n        return location;\r\n    });\r\n    let index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\r\n    let action = Action.Pop;\r\n    let location = entries[index];\r\n    let listeners = createEvents();\r\n    let blockers = createEvents();\r\n    function createHref(to) {\r\n        return typeof to === 'string' ? to : createPath(to);\r\n    }\r\n    function getNextLocation(to, state = null) {\r\n        return readOnly({\r\n            ...location,\r\n            ...(typeof to === 'string' ? parsePath(to) : to),\r\n            state,\r\n            key: createKey()\r\n        });\r\n    }\r\n    function allowTx(action, location, retry) {\r\n        return (!blockers.length || (blockers.call({ action, location, retry }), false));\r\n    }\r\n    function applyTx(nextAction, nextLocation, updateMode) {\r\n        action = nextAction;\r\n        location = nextLocation;\r\n        listeners.call({ action, location, updateMode });\r\n    }\r\n    function push(to, state, updateMode, noListener) {\r\n        let nextAction = Action.Push;\r\n        let nextLocation = getNextLocation(to, state);\r\n        function retry() {\r\n            push(to, state);\r\n        }\r\n        warning(location.pathname.charAt(0) === '/', `Relative pathnames are not supported in memory history.push(${JSON.stringify(to)})`);\r\n        if (allowTx(nextAction, nextLocation, retry)) {\r\n            index += 1;\r\n            entries.splice(index, entries.length, nextLocation);\r\n            if (noListener === true) {\r\n                // \r\n            }\r\n            else {\r\n                applyTx(nextAction, nextLocation, (updateMode === undefined) ? UpdateMode.FromCode : updateMode);\r\n            }\r\n        }\r\n    }\r\n    function replace(to, state, updateMode, noListener) {\r\n        let nextAction = Action.Replace;\r\n        let nextLocation = getNextLocation(to, state);\r\n        function retry() {\r\n            replace(to, state);\r\n        }\r\n        warning(location.pathname.charAt(0) === '/', `Relative pathnames are not supported in memory history.replace(${JSON.stringify(to)})`);\r\n        if (allowTx(nextAction, nextLocation, retry)) {\r\n            entries[index] = nextLocation;\r\n            if (noListener === true) {\r\n                // \r\n            }\r\n            else {\r\n                applyTx(nextAction, nextLocation, (updateMode === undefined) ? UpdateMode.FromCode : updateMode);\r\n            }\r\n        }\r\n    }\r\n    function go(delta, updateMode) {\r\n        let nextIndex = clamp(index + delta, 0, entries.length - 1);\r\n        let nextAction = Action.Pop;\r\n        let nextLocation = entries[nextIndex];\r\n        function retry() {\r\n            go(delta);\r\n        }\r\n        if (allowTx(nextAction, nextLocation, retry)) {\r\n            index = nextIndex;\r\n            applyTx(nextAction, nextLocation, UpdateMode.FromBrowser);\r\n        }\r\n    }\r\n    let history = {\r\n        get index() {\r\n            return index;\r\n        },\r\n        get action() {\r\n            return action;\r\n        },\r\n        get location() {\r\n            return location;\r\n        },\r\n        createHref,\r\n        push,\r\n        replace,\r\n        go,\r\n        back() {\r\n            go(-1);\r\n        },\r\n        forward() {\r\n            go(1);\r\n        },\r\n        listen(listener) {\r\n            return listeners.push(listener);\r\n        },\r\n        block(blocker) {\r\n            return blockers.push(blocker);\r\n        }\r\n    };\r\n    return history;\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n// UTILS\r\n////////////////////////////////////////////////////////////////////////////////\r\nfunction clamp(n, lowerBound, upperBound) {\r\n    return Math.min(Math.max(n, lowerBound), upperBound);\r\n}\r\nfunction promptBeforeUnload(event) {\r\n    // Cancel the event.\r\n    event.preventDefault();\r\n    // Chrome (and legacy IE) requires returnValue to be set.\r\n    event.returnValue = '';\r\n}\r\nfunction createEvents() {\r\n    let handlers = [];\r\n    return {\r\n        get length() {\r\n            return handlers.length;\r\n        },\r\n        push(fn) {\r\n            handlers.push(fn);\r\n            return function () {\r\n                handlers = handlers.filter(handler => handler !== fn);\r\n            };\r\n        },\r\n        call(arg) {\r\n            handlers.forEach(fn => fn && fn(arg));\r\n        }\r\n    };\r\n}\r\nfunction createKey() {\r\n    return Math.random()\r\n        .toString(36)\r\n        .substring(2, 10);\r\n}\r\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/ReactTraining/history/tree/master/docs/api-reference.md#createpath\r\n */\r\nfunction createPath({ pathname = '/', search = '', hash = '' }) {\r\n    return pathname + search + hash;\r\n}\r\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/ReactTraining/history/tree/master/docs/api-reference.md#parsepath\r\n */\r\nfunction parsePath(path) {\r\n    let partialPath = {};\r\n    if (path) {\r\n        let hashIndex = path.indexOf('#');\r\n        if (hashIndex >= 0) {\r\n            partialPath.hash = path.substring(hashIndex);\r\n            path = path.substring(0, hashIndex);\r\n        }\r\n        let searchIndex = path.indexOf('?');\r\n        if (searchIndex >= 0) {\r\n            partialPath.search = path.substring(searchIndex);\r\n            path = path.substring(0, searchIndex);\r\n        }\r\n        if (path) {\r\n            partialPath.pathname = path;\r\n        }\r\n    }\r\n    return partialPath;\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingStateRouter/src/history.ts?");

/***/ }),

/***/ "./libs/dependingStateRouter/src/index.ts":
/*!************************************************!*\
  !*** ./libs/dependingStateRouter/src/index.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSNavigatorStore\": () => (/* reexport safe */ _DSNavigatorStore__WEBPACK_IMPORTED_MODULE_6__.DSNavigatorStore),\n/* harmony export */   \"DSNavigatorWithRoutesStore\": () => (/* reexport safe */ _DSNavigatorWithRoutesStore__WEBPACK_IMPORTED_MODULE_8__.DSNavigatorWithRoutesStore),\n/* harmony export */   \"DSRouterStore\": () => (/* reexport safe */ _DSRouterStore__WEBPACK_IMPORTED_MODULE_4__.DSRouterStore),\n/* harmony export */   \"DSRouterValue\": () => (/* reexport safe */ _DSRouterValue__WEBPACK_IMPORTED_MODULE_3__.DSRouterValue),\n/* harmony export */   \"HistoryAction\": () => (/* reexport safe */ _history__WEBPACK_IMPORTED_MODULE_0__.Action),\n/* harmony export */   \"UpdateMode\": () => (/* reexport safe */ _history__WEBPACK_IMPORTED_MODULE_0__.UpdateMode),\n/* harmony export */   \"createBrowserHistory\": () => (/* reexport safe */ _history__WEBPACK_IMPORTED_MODULE_0__.createBrowserHistory),\n/* harmony export */   \"createHashHistory\": () => (/* reexport safe */ _history__WEBPACK_IMPORTED_MODULE_0__.createHashHistory),\n/* harmony export */   \"createMemoryHistory\": () => (/* reexport safe */ _history__WEBPACK_IMPORTED_MODULE_0__.createMemoryHistory),\n/* harmony export */   \"createPath\": () => (/* reexport safe */ _history__WEBPACK_IMPORTED_MODULE_0__.createPath),\n/* harmony export */   \"dsRouterBuilder\": () => (/* reexport safe */ _DSRouterAction__WEBPACK_IMPORTED_MODULE_2__.dsRouterBuilder),\n/* harmony export */   \"getDSRouterValueInitial\": () => (/* reexport safe */ _DSRouterValue__WEBPACK_IMPORTED_MODULE_3__.getDSRouterValueInitial),\n/* harmony export */   \"getRouterValueInitial\": () => (/* reexport safe */ _DSRouterStore__WEBPACK_IMPORTED_MODULE_4__.getRouterValueInitial),\n/* harmony export */   \"navigatorBuilder\": () => (/* reexport safe */ _DSNavigatorActions__WEBPACK_IMPORTED_MODULE_5__.navigatorBuilder),\n/* harmony export */   \"navigatorSetLocation\": () => (/* reexport safe */ _DSNavigatorActions__WEBPACK_IMPORTED_MODULE_5__.navigatorSetLocation),\n/* harmony export */   \"navigatorWithRoutesBuilder\": () => (/* reexport safe */ _DSNavigatorWithRoutesAction__WEBPACK_IMPORTED_MODULE_7__.navigatorWithRoutesBuilder),\n/* harmony export */   \"parsePath\": () => (/* reexport safe */ _history__WEBPACK_IMPORTED_MODULE_0__.parsePath),\n/* harmony export */   \"routerLocationChanged\": () => (/* reexport safe */ _DSRouterAction__WEBPACK_IMPORTED_MODULE_2__.routerLocationChanged),\n/* harmony export */   \"routerPush\": () => (/* reexport safe */ _DSRouterAction__WEBPACK_IMPORTED_MODULE_2__.routerPush),\n/* harmony export */   \"routerReplace\": () => (/* reexport safe */ _DSRouterAction__WEBPACK_IMPORTED_MODULE_2__.routerReplace)\n/* harmony export */ });\n/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./history */ \"./libs/dependingStateRouter/src/history.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./libs/dependingStateRouter/src/types.ts\");\n/* harmony import */ var _DSRouterAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DSRouterAction */ \"./libs/dependingStateRouter/src/DSRouterAction.ts\");\n/* harmony import */ var _DSRouterValue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DSRouterValue */ \"./libs/dependingStateRouter/src/DSRouterValue.ts\");\n/* harmony import */ var _DSRouterStore__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DSRouterStore */ \"./libs/dependingStateRouter/src/DSRouterStore.ts\");\n/* harmony import */ var _DSNavigatorActions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DSNavigatorActions */ \"./libs/dependingStateRouter/src/DSNavigatorActions.ts\");\n/* harmony import */ var _DSNavigatorStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DSNavigatorStore */ \"./libs/dependingStateRouter/src/DSNavigatorStore.ts\");\n/* harmony import */ var _DSNavigatorWithRoutesAction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DSNavigatorWithRoutesAction */ \"./libs/dependingStateRouter/src/DSNavigatorWithRoutesAction.ts\");\n/* harmony import */ var _DSNavigatorWithRoutesStore__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DSNavigatorWithRoutesStore */ \"./libs/dependingStateRouter/src/DSNavigatorWithRoutesStore.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://app/./libs/dependingStateRouter/src/index.ts?");

/***/ }),

/***/ "./libs/dependingStateRouter/src/injectQuery.ts":
/*!******************************************************!*\
  !*** ./libs/dependingStateRouter/src/injectQuery.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"injectQuery\": () => (/* binding */ injectQuery)\n/* harmony export */ });\n/**\r\n * Adds query to location.\r\n * Utilises the search prop of location to construct query.\r\n */\r\nfunction injectQuery(location) {\r\n    if (location && typeof location.query !== \"undefined\") {\r\n        // Don't inject query if it already exists in history\r\n        return location;\r\n    }\r\n    const searchQuery = location && location.search;\r\n    if (typeof searchQuery !== 'string' || searchQuery.length === 0) {\r\n        return {\r\n            ...location,\r\n            query: {}\r\n        };\r\n    }\r\n    // Ignore the `?` part of the search string e.g. ?username=codejockie\r\n    const search = searchQuery.substring(1);\r\n    // Split the query string on `&` e.g. ?username=codejockie&name=Kennedy\r\n    const queries = search.split('&');\r\n    // Contruct query\r\n    const query = queries.reduce((acc, currentQuery) => {\r\n        // Split on `=`, to get key and value\r\n        const [queryKey, queryValue] = currentQuery.split('=');\r\n        return {\r\n            ...acc,\r\n            [queryKey]: queryValue\r\n        };\r\n    }, {});\r\n    return {\r\n        ...location,\r\n        query\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingStateRouter/src/injectQuery.ts?");

/***/ }),

/***/ "./libs/dependingStateRouter/src/matchPath.ts":
/*!****************************************************!*\
  !*** ./libs/dependingStateRouter/src/matchPath.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"matchPath\": () => (/* binding */ matchPath)\n/* harmony export */ });\n/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path-to-regexp */ \"./node_modules/path-to-regexp/dist.es2015/index.js\");\n\r\nconst cache = {};\r\nconst cacheLimit = 100;\r\n//let cacheCount = 0;\r\nfunction compilePath(path, options) {\r\n    const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\r\n    let pathCache = cache[cacheKey] || (cache[cacheKey] = {});\r\n    if (pathCache[path])\r\n        return pathCache[path];\r\n    const keys = [];\r\n    const regexp = (0,path_to_regexp__WEBPACK_IMPORTED_MODULE_0__.pathToRegexp)(path, keys, options);\r\n    const result = { regexp, keys };\r\n    if (Object.keys(pathCache).length >= cacheLimit) {\r\n        pathCache = (cache[cacheKey] = {});\r\n    }\r\n    // if (cacheCount < cacheLimit) {\r\n    //     pathCache[path] = result;\r\n    //     cacheCount++;\r\n    // }\r\n    pathCache[path] = result;\r\n    return result;\r\n}\r\n/**\r\n * Public API for matching a URL pathname to a path.\r\n */\r\nfunction matchPath(pathname, options) {\r\n    if (typeof options === \"string\" || Array.isArray(options)) {\r\n        options = { path: options };\r\n    }\r\n    const { path, exact = false, strict = false, sensitive = false } = options;\r\n    const paths = [].concat(path);\r\n    const r = (matched, path) => {\r\n        if (!path && path !== \"\")\r\n            return null;\r\n        if (matched)\r\n            return matched;\r\n        const { regexp, keys } = compilePath(path, {\r\n            end: exact,\r\n            strict,\r\n            sensitive\r\n        });\r\n        const match = regexp.exec(pathname);\r\n        if (!match)\r\n            return null;\r\n        const [url, ...values] = match;\r\n        const isExact = pathname === url;\r\n        if (exact && !isExact)\r\n            return null;\r\n        const result = {\r\n            path,\r\n            url: path === \"/\" && url === \"\" ? \"/\" : url,\r\n            isExact,\r\n            params: keys.reduce((memo, key, index) => {\r\n                memo[key.name] = values[index];\r\n                return memo;\r\n            }, {})\r\n        };\r\n        return result;\r\n    };\r\n    return paths.reduce(r, null);\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (matchPath);\r\n\n\n//# sourceURL=webpack://app/./libs/dependingStateRouter/src/matchPath.ts?");

/***/ }),

/***/ "./libs/dependingStateRouter/src/types.ts":
/*!************************************************!*\
  !*** ./libs/dependingStateRouter/src/types.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\r\n\n\n//# sourceURL=webpack://app/./libs/dependingStateRouter/src/types.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSArrayHelper.ts":
/*!**************************************************!*\
  !*** ./libs/dependingState/src/DSArrayHelper.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dsIsArrayEqual\": () => (/* binding */ dsIsArrayEqual)\n/* harmony export */ });\nfunction dsIsArrayEqual(arrOld, arrNew, fnIsEqual) {\r\n    if (arrOld.length !== arrNew.length) {\r\n        return false;\r\n    }\r\n    for (let idx = 0; idx < arrNew.length; idx++) {\r\n        if (!fnIsEqual(arrOld[idx], arrNew[idx])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSArrayHelper.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSArrayStore.ts":
/*!*************************************************!*\
  !*** ./libs/dependingState/src/DSArrayStore.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSArrayStore\": () => (/* binding */ DSArrayStore)\n/* harmony export */ });\n/* harmony import */ var _DSValueStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DSValueStore */ \"./libs/dependingState/src/DSValueStore.ts\");\n/* harmony import */ var _DSStateValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DSStateValue */ \"./libs/dependingState/src/DSStateValue.ts\");\n\r\n\r\nclass DSArrayStore extends _DSValueStore__WEBPACK_IMPORTED_MODULE_0__.DSValueStore {\r\n    // dirtyEntities: { stateValue: IDSStateValue<Value>, properties?: Set<keyof Value> }[];\r\n    // isProcessDirtyEntityConfigured: boolean;\r\n    constructor(storeName, configuration) {\r\n        super(storeName, configuration);\r\n        this.entities = [];\r\n        // this.dirtyEntities = []\r\n        // this.isProcessDirtyEntityConfigured = false;\r\n    }\r\n    getEntities() {\r\n        return this.entities.map((e, index) => ({ key: index, stateValue: e }));\r\n    }\r\n    create(value) {\r\n        const create = this.configuration.create;\r\n        if (create !== undefined) {\r\n            const result = create(value);\r\n            this.attach(result);\r\n            return result;\r\n        }\r\n        else {\r\n            const result = new _DSStateValue__WEBPACK_IMPORTED_MODULE_1__.DSStateValue(value);\r\n            this.attach(result);\r\n            return result;\r\n        }\r\n    }\r\n    // public initializeRegisteredEvents(): void {\r\n    //     this.isProcessDirtyEntityConfigured = this.hasProcessDirtyEntityConfigured();\r\n    //     this.isProcessDirtyConfigured = this.isProcessDirtyEntityConfigured || this.hasProcessDirtyConfigured();\r\n    // }\r\n    // public hasProcessDirty(): boolean {\r\n    //     if (this.configuration.processDirty !== undefined) { return true; }\r\n    //     if (!(this.processDirty === DSArrayStore.prototype.processDirty)) { return true; }\r\n    //     return false;\r\n    // }\r\n    // public hasProcessDirtyEntityConfigured(): boolean {\r\n    //     if ((this.configuration as ConfigurationDSArrayValueStore<Value>).processDirtyEntity !== undefined) { return true; }\r\n    //     if (!(this.processDirtyEntity === DSArrayStore.prototype.processDirtyEntity)) { return true; }\r\n    //     return false;\r\n    // }\r\n    attach(stateValue) {\r\n        if (stateValue.setStore(this)) {\r\n            this.entities.push(stateValue);\r\n            const index = this.entities.length - 1;\r\n            this.emitEvent(\"attach\", { entity: stateValue, index: index });\r\n        }\r\n    }\r\n    detach(stateValue) {\r\n        const index = this.entities.findIndex((item) => item === stateValue);\r\n        if (index < 0) {\r\n            // do nothing\r\n        }\r\n        else {\r\n            const oldValue = this.entities.splice(index, 1)[0];\r\n            oldValue.store = undefined;\r\n            this.emitEvent(\"detach\", { entity: oldValue, index: index });\r\n        }\r\n    }\r\n    listenEventAttach(msg, callback) {\r\n        return this.listenEvent(msg, \"attach\", callback);\r\n    }\r\n    listenEventValue(msg, callback) {\r\n        return this.listenEvent(msg, \"value\", callback);\r\n    }\r\n    listenEventDetach(msg, callback) {\r\n        return this.listenEvent(msg, \"detach\", callback);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSArrayStore.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSDeepEquals.ts":
/*!*************************************************!*\
  !*** ./libs/dependingState/src/DSDeepEquals.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deepEquals\": () => (/* binding */ deepEquals)\n/* harmony export */ });\nfunction deepEquals(a, b, ignoreStateVersion = false) {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    if (a && b && typeof a == 'object' && typeof b == 'object') {\r\n        if (a.constructor !== b.constructor) {\r\n            return false;\r\n        }\r\n        if (Array.isArray(a)) {\r\n            let length = a.length;\r\n            if (length != b.length) {\r\n                return false;\r\n            }\r\n            for (let i = length - 1; i >= 0; i--) {\r\n                if (!deepEquals(a[i], b[i], false)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        if ((a instanceof Map) && (b instanceof Map)) {\r\n            if (a.size !== b.size) {\r\n                return false;\r\n            }\r\n            for (let i of a.entries()) {\r\n                if (!b.has(i[0])) {\r\n                    return false;\r\n                }\r\n            }\r\n            for (let i of a.entries()) {\r\n                if (!deepEquals(i[1], b.get(i[0]), false)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        if ((a instanceof Set) && (b instanceof Set)) {\r\n            if (a.size !== b.size) {\r\n                return false;\r\n            }\r\n            for (let i of a.entries()) {\r\n                if (!b.has(i[0])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\r\n            let length = a.length;\r\n            if (length != b.length) {\r\n                return false;\r\n            }\r\n            for (let i = length - 1; i >= 0; i--) {\r\n                if (a[i] !== b[i]) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        if (a.constructor === RegExp)\r\n            return a.source === b.source && a.flags === b.flags;\r\n        if (a.valueOf !== Object.prototype.valueOf)\r\n            return a.valueOf() === b.valueOf();\r\n        if (a.toString !== Object.prototype.toString)\r\n            return a.toString() === b.toString();\r\n        {\r\n            let aKeys = Object.keys(a);\r\n            let bKeys = Object.keys(b);\r\n            if (ignoreStateVersion) {\r\n                {\r\n                    let i = aKeys.indexOf(\"stateVersion\");\r\n                    if (i >= 0) {\r\n                        aKeys.splice(i, 1);\r\n                    }\r\n                }\r\n                {\r\n                    let i = bKeys.indexOf(\"stateVersion\");\r\n                    if (i >= 0) {\r\n                        bKeys.splice(i, 1);\r\n                    }\r\n                }\r\n            }\r\n            if (aKeys.length !== bKeys.length) {\r\n                return false;\r\n            }\r\n            for (let i = aKeys.length - 1; i >= 0; i--) {\r\n                if (Object.prototype.hasOwnProperty.call(a, aKeys[i])) {\r\n                    if (!Object.prototype.hasOwnProperty.call(b, aKeys[i])) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            for (let i = aKeys.length - 1; i >= 0; i--) {\r\n                var key = aKeys[i];\r\n                if (!deepEquals(a[key], b[key], false)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    else {\r\n        // true if both NaN, false otherwise\r\n        return a !== a && b !== b;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSDeepEquals.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSEntityStore.ts":
/*!**************************************************!*\
  !*** ./libs/dependingState/src/DSEntityStore.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSEntityStore\": () => (/* binding */ DSEntityStore)\n/* harmony export */ });\n/* harmony import */ var _DSMapStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DSMapStore */ \"./libs/dependingState/src/DSMapStore.ts\");\n/* harmony import */ var _DSStateValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DSStateValue */ \"./libs/dependingState/src/DSStateValue.ts\");\n\r\n\r\nclass DSEntityStore extends _DSMapStore__WEBPACK_IMPORTED_MODULE_0__.DSMapStore {\r\n    constructor(storeName, configuration) {\r\n        super(storeName, configuration);\r\n    }\r\n    set(value) {\r\n        const getKey = this.configuration.getKey;\r\n        const create = this.configuration.create;\r\n        if (create !== undefined) {\r\n            const result = create(value);\r\n            const key = getKey(value);\r\n            this.attach(key, result);\r\n            return result;\r\n        }\r\n        else {\r\n            const result = new _DSStateValue__WEBPACK_IMPORTED_MODULE_1__.DSStateValue(value);\r\n            const key = getKey(value);\r\n            this.attach(key, result);\r\n            return result;\r\n        }\r\n    }\r\n    setMany(values) {\r\n        values.forEach(this.set, this);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSEntityStore.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSLog.ts":
/*!******************************************!*\
  !*** ./libs/dependingState/src/DSLog.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSLog\": () => (/* binding */ DSLog),\n/* harmony export */   \"DSLogACME\": () => (/* binding */ DSLogACME),\n/* harmony export */   \"DSLogBase\": () => (/* binding */ DSLogBase),\n/* harmony export */   \"defaultConvertExtraArg\": () => (/* binding */ defaultConvertExtraArg),\n/* harmony export */   \"dsLog\": () => (/* binding */ dsLog)\n/* harmony export */ });\nfunction noop() {\r\n}\r\nfunction warnIfCalled(...data) {\r\n    console.warn(\"warn log was not conditional. please add 'if (dsLog.enabled) { }' \");\r\n    console.trace(data);\r\n}\r\n//\r\nclass DSLogBase {\r\n    constructor(name) {\r\n        this.name = name;\r\n        this.enabled = false;\r\n        this.logEnabled = false;\r\n        this.enableTiming = false;\r\n        this.mode = \"disabled\";\r\n        this.group = noop;\r\n        this.groupEnd = noop;\r\n        this.debug = noop;\r\n        this.info = noop;\r\n        this.log = noop;\r\n        this.warn = noop;\r\n        this.error = noop;\r\n        this.trace = noop;\r\n        this.flags = new Set();\r\n    }\r\n    initialize(mode) {\r\n        // for now\r\n        // dsLog.setSelfInGlobal();\r\n        // dsLog.setMode(\"enabled\");\r\n        if (mode === undefined) {\r\n            this.applyFromLocalStorage();\r\n        }\r\n        else {\r\n            this.setMode(mode);\r\n        }\r\n        if (this.enabled) {\r\n            dsLog.setSelfInGlobal();\r\n        }\r\n    }\r\n    attach(storeManager) {\r\n        this.storeManager = storeManager;\r\n        // TODO: thinkof same as initialize\r\n        if (this.enabled) {\r\n            storeManager.enableTiming = this.enableTiming;\r\n            storeManager.setSelfInGlobal();\r\n        }\r\n    }\r\n    setDisabled() {\r\n        // nop be quiet\r\n        // console.debug(`${this.name} setDisabled`);\r\n        this.enabled = false;\r\n        this.logEnabled = false;\r\n        this.mode = \"disabled\";\r\n        this.group = noop;\r\n        this.groupEnd = noop;\r\n        this.debug = noop;\r\n        this.info = noop;\r\n        this.log = noop;\r\n        this.warn = noop;\r\n        this.error = noop;\r\n        this.trace = noop;\r\n        return this;\r\n    }\r\n    setEnabled() {\r\n        if (this.mode == \"enabled\") {\r\n            return this;\r\n        }\r\n        console.debug(`${this.name} setEnabled`);\r\n        this.enabled = true;\r\n        this.logEnabled = true;\r\n        this.mode = \"enabled\";\r\n        this.group = console.group;\r\n        this.groupEnd = console.groupEnd;\r\n        this.debug = console.debug;\r\n        this.info = console.info;\r\n        this.log = console.log;\r\n        this.warn = console.warn;\r\n        this.error = console.error;\r\n        this.trace = console.trace;\r\n        return this;\r\n    }\r\n    setWarnIfCalled() {\r\n        if (this.mode == \"WarnIfCalled\") {\r\n            return this;\r\n        }\r\n        console.debug(`${this.name} setWarnIfCalled`);\r\n        this.enabled = true;\r\n        this.logEnabled = false;\r\n        this.mode = \"WarnIfCalled\";\r\n        this.group = warnIfCalled;\r\n        this.groupEnd = warnIfCalled;\r\n        this.debug = warnIfCalled;\r\n        this.info = warnIfCalled;\r\n        this.log = warnIfCalled;\r\n        this.warn = warnIfCalled;\r\n        this.error = warnIfCalled;\r\n        this.trace = warnIfCalled;\r\n        return this;\r\n    }\r\n    setMode(mode) {\r\n        if (mode === \"enabled\") {\r\n            this.setEnabled();\r\n        }\r\n        else if (mode === \"WarnIfCalled\") {\r\n            this.setWarnIfCalled();\r\n        }\r\n        else if (mode === \"disabled\") {\r\n            this.setDisabled();\r\n        }\r\n        else {\r\n            console.debug(`${this.name} setMode applyFromLocalStorage`);\r\n            this.applyFromLocalStorage();\r\n        }\r\n    }\r\n    saveToLocalStorage(key) {\r\n        const data = {\r\n            mode: this.mode\r\n        };\r\n        window.localStorage.setItem(key || this.name, JSON.stringify(data));\r\n        return this;\r\n    }\r\n    applyFromLocalStorage(key) {\r\n        const json = window.localStorage.getItem(key || this.name);\r\n        if (json) {\r\n            const data = JSON.parse(json);\r\n            if (data) {\r\n                if (typeof data.mode === \"string\") {\r\n                    if (data.mode === \"enabled\") {\r\n                        this.setEnabled();\r\n                    }\r\n                    else if (data.mode === \"WarnIfCalled\") {\r\n                        this.setWarnIfCalled();\r\n                    }\r\n                    else {\r\n                        this.setDisabled();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    isEnabled(flag) {\r\n        if (this.enabled) {\r\n            if (this.flags.size === 0) {\r\n                return true;\r\n            }\r\n            else {\r\n                return this.flags.has(flag);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nfunction defaultConvertExtraArg(currentExtraArg) {\r\n    if (currentExtraArg === undefined) {\r\n        return \"undefined\";\r\n    }\r\n    if (currentExtraArg === null) {\r\n        return \"null\";\r\n    }\r\n    if (typeof currentExtraArg === \"string\") {\r\n        return currentExtraArg;\r\n    }\r\n    if (currentExtraArg.constructor && typeof currentExtraArg.constructor.name === \"string\") {\r\n        return currentExtraArg.constructor.name;\r\n    }\r\n    return `${currentExtraArg}`;\r\n}\r\nfunction templateAMCE(log, currentApp, currentClass, currentMethod, currentExtraArg, //React.Component\r\nmessage = undefined) {\r\n    let effectiveArg = \"\";\r\n    let calcedEffectiveArg = false;\r\n    if (message === undefined) {\r\n        message = \"\";\r\n    }\r\n    if (this.amceEnabled) {\r\n        effectiveArg = this.convertArg(currentExtraArg);\r\n        calcedEffectiveArg = true;\r\n        if ((this.watchoutApp === undefined || this.watchoutApp === currentApp)\r\n            && (this.watchoutClass === undefined || this.watchoutClass === currentClass)\r\n            && (this.watchoutMethod === undefined || this.watchoutMethod === currentMethod)\r\n            && (this.watchoutExtraArg === undefined || this.watchoutExtraArg === effectiveArg)) {\r\n            this.watchoutHit++;\r\n            if (dsLog.logEnabled) {\r\n                console.warn(currentApp, currentClass, currentMethod, effectiveArg, this.watchoutHit, message);\r\n            }\r\n            if (this.watchoutStopAt === this.watchoutHit) {\r\n                /*\r\n                    the condition matched. have a look at the call stack.\r\n                */\r\n                debugger;\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    if (dsLog.logEnabled) {\r\n        if (!calcedEffectiveArg) {\r\n            effectiveArg = this.convertArg(currentExtraArg);\r\n            calcedEffectiveArg = true;\r\n        }\r\n        log(currentApp, currentClass, currentMethod, effectiveArg, message);\r\n    }\r\n}\r\nclass DSLogACME extends DSLogBase {\r\n    constructor(name) {\r\n        super(name);\r\n        this.convertArg = defaultConvertExtraArg;\r\n        this.amceEnabled = false;\r\n        this.watchoutApp = undefined;\r\n        this.watchoutClass = undefined;\r\n        this.watchoutMethod = undefined;\r\n        this.watchoutExtraArg = undefined;\r\n        this.watchoutHit = 0;\r\n        this.watchoutStopAt = undefined;\r\n        this.debugACME = this.debug;\r\n        this.infoACME = this.info;\r\n        this.logACME = this.log;\r\n        this.warnACME = this.warn;\r\n        this.errorACME = this.error;\r\n    }\r\n    setDisabled() {\r\n        super.setDisabled();\r\n        if (this.amceEnabled) {\r\n            this.bindACME();\r\n        }\r\n        else {\r\n            this.enabled = false;\r\n            this.debugACME = noop;\r\n            this.infoACME = noop;\r\n            this.logACME = noop;\r\n            this.warnACME = noop;\r\n            this.errorACME = noop;\r\n        }\r\n        return this;\r\n    }\r\n    setEnabled() {\r\n        super.setEnabled();\r\n        this.bindACME();\r\n        return this;\r\n    }\r\n    setWarnIfCalled() {\r\n        super.setWarnIfCalled();\r\n        this.bindACME();\r\n        return this;\r\n    }\r\n    setWatchout(watchoutApp = undefined, watchoutClass = undefined, watchoutMethod = undefined, watchoutExtraArg = undefined, watchoutStopAt = undefined) {\r\n        this.watchoutApp = watchoutApp;\r\n        this.watchoutClass = watchoutClass;\r\n        this.watchoutMethod = watchoutMethod;\r\n        this.watchoutExtraArg = watchoutExtraArg;\r\n        this.watchoutStopAt = watchoutStopAt;\r\n        const oldwatchoutEnabled = this.amceEnabled;\r\n        this.amceEnabled = ((watchoutApp !== undefined)\r\n            || (watchoutClass !== undefined)\r\n            || (watchoutMethod !== undefined)\r\n            || (watchoutExtraArg !== undefined));\r\n        if (oldwatchoutEnabled != this.amceEnabled) {\r\n            this.bindACME();\r\n        }\r\n        dsLog.info(\"DS setWatchout\", watchoutApp, watchoutClass, watchoutMethod, watchoutExtraArg);\r\n        this.enabled = this.amceEnabled || this.logEnabled;\r\n        return this;\r\n    }\r\n    bindACME() {\r\n        if (this.amceEnabled) {\r\n            this.enabled = true;\r\n            this.infoACME = templateAMCE.bind(this, console.info);\r\n            this.debugACME = templateAMCE.bind(this, console.debug);\r\n            this.logACME = templateAMCE.bind(this, console.log);\r\n            this.warnACME = templateAMCE.bind(this, console.warn);\r\n            this.errorACME = templateAMCE.bind(this, console.error);\r\n        }\r\n        else {\r\n            this.debugACME = this.debug;\r\n            this.infoACME = this.info;\r\n            this.logACME = this.log;\r\n            this.warnACME = this.warn;\r\n            this.errorACME = this.error;\r\n            this.enabled = this.logEnabled;\r\n        }\r\n    }\r\n    clearFromLocalStorage(key) {\r\n        if (!key) {\r\n            key = this.name;\r\n        }\r\n        window.localStorage.removeItem(key);\r\n        return this;\r\n    }\r\n    saveToLocalStorage(key) {\r\n        const data = (this.amceEnabled) ? {\r\n            mode: this.mode,\r\n            watchoutEnabled: this.amceEnabled,\r\n            watchoutApp: this.watchoutApp,\r\n            watchoutClass: this.watchoutClass,\r\n            watchoutMethod: this.watchoutMethod,\r\n            watchoutExtraArg: this.watchoutExtraArg,\r\n            watchoutStopAt: this.watchoutStopAt\r\n        } : {\r\n            mode: this.mode\r\n        };\r\n        window.localStorage.setItem(key || this.name, JSON.stringify(data));\r\n        console.info(`window.localStorage.setItem('${(key || this.name)}', '${JSON.stringify(data)}');`);\r\n        return this;\r\n    }\r\n    applyFromLocalStorage(key) {\r\n        const json = window.localStorage.getItem(key || this.name);\r\n        if (json) {\r\n            const data = JSON.parse(json);\r\n            if (data) {\r\n                if (typeof data.mode === \"string\") {\r\n                    if (data.mode === \"enabled\") {\r\n                        this.setEnabled();\r\n                    }\r\n                    else if (data.mode === \"WarnIfCalled\") {\r\n                        this.setWarnIfCalled();\r\n                    }\r\n                    else {\r\n                        this.setDisabled();\r\n                    }\r\n                }\r\n                if (data.watchoutEnabled === true) {\r\n                    console.info(\"DS DSLogApp applyFromLocalStorage watchoutEnabled\");\r\n                    this.setWatchout((typeof data.watchoutApp === \"string\") ? data.watchoutApp : undefined, (typeof data.watchoutClass === \"string\") ? data.watchoutClass : undefined, (typeof data.watchoutMethod === \"string\") ? data.watchoutMethod : undefined, (typeof data.watchoutExtraArg === \"string\") ? data.watchoutExtraArg : undefined, (typeof data.watchoutStopAt === \"number\") ? data.watchoutStopAt : undefined);\r\n                }\r\n                else {\r\n                    this.amceEnabled = false;\r\n                    this.enabled = this.logEnabled;\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n}\r\nclass DSLog extends DSLogACME {\r\n    constructor(name) {\r\n        super(name || \"dsLog\");\r\n    }\r\n    setSelfInGlobal() {\r\n        if (typeof window !== \"undefined\") {\r\n            window.dsLog = this;\r\n        }\r\n    }\r\n}\r\nconst dsLog = new DSLog(\"dsLog\");\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSLog.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSLooseStore.ts":
/*!*************************************************!*\
  !*** ./libs/dependingState/src/DSLooseStore.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSLooseStore\": () => (/* binding */ DSLooseStore)\n/* harmony export */ });\n/* harmony import */ var _DSValueStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DSValueStore */ \"./libs/dependingState/src/DSValueStore.ts\");\n\r\nclass DSLooseStore extends _DSValueStore__WEBPACK_IMPORTED_MODULE_0__.DSValueStore {\r\n    // dirtyEntities: { stateValue: IDSStateValue<Value>, properties?: Set<keyof Value> }[];\r\n    // isProcessDirtyEntityConfigured: boolean;\r\n    constructor(storeName, configuration) {\r\n        super(storeName, configuration);\r\n        // this.dirtyEntities = []\r\n        // this.isProcessDirtyEntityConfigured = false;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSLooseStore.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSMapStore.ts":
/*!***********************************************!*\
  !*** ./libs/dependingState/src/DSMapStore.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSMapStore\": () => (/* binding */ DSMapStore)\n/* harmony export */ });\n/* harmony import */ var _DSValueStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DSValueStore */ \"./libs/dependingState/src/DSValueStore.ts\");\n/* harmony import */ var _DSStateValue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DSStateValue */ \"./libs/dependingState/src/DSStateValue.ts\");\n\r\n\r\nclass DSMapStore extends _DSValueStore__WEBPACK_IMPORTED_MODULE_0__.DSValueStore {\r\n    // dirtyEntities: { stateValue: IDSStateValue<Value>, properties?: Set<keyof Value> }[];\r\n    // isProcessDirtyEntityConfigured: boolean;\r\n    constructor(storeName, configuration) {\r\n        super(storeName, configuration);\r\n        this.entities = new Map();\r\n        // this.dirtyEntities = [];\r\n        // this.isProcessDirtyEntityConfigured = false;\r\n    }\r\n    create(key, value) {\r\n        const create = this.configuration.create;\r\n        if (create !== undefined) {\r\n            const result = create(value);\r\n            this.attach(key, result);\r\n            return result;\r\n        }\r\n        else {\r\n            const result = new _DSStateValue__WEBPACK_IMPORTED_MODULE_1__.DSStateValue(value);\r\n            this.attach(key, result);\r\n            return result;\r\n        }\r\n    }\r\n    get(key) {\r\n        return this.entities.get(key);\r\n    }\r\n    getEntities() {\r\n        return Array.from(this.entities.entries()).map((e) => ({ key: e[0], stateValue: e[1] }));\r\n    }\r\n    // public initializeRegisteredEvents(): void {\r\n    //     this.isProcessDirtyEntityConfigured = this.hasProcessDirtyEntityConfigured();\r\n    //     this.isProcessDirtyConfigured = this.isProcessDirtyEntityConfigured || this.hasProcessDirtyConfigured();\r\n    // }\r\n    // public hasProcessDirty(): boolean {\r\n    //     if (this.configuration.processDirty !== undefined) { return true; }\r\n    //     if (!(this.processDirty === DSMapStore.prototype.processDirty)) { return true; }\r\n    //     return false;\r\n    // }\r\n    // public hasProcessDirtyEntityConfigured(): boolean {\r\n    //     if ((this.configuration as ConfigurationDSMapValueStore<Value>).processDirtyEntity !== undefined) { return true; }\r\n    //     if (!(this.processDirtyEntity === DSMapStore.prototype.processDirtyEntity)) { return true; }\r\n    //     return false;\r\n    // }\r\n    attach(key, stateValue) {\r\n        if (stateValue.setStore(this)) {\r\n            const oldValue = this.entities.get(key);\r\n            if (oldValue === undefined) {\r\n                this.entities.set(key, stateValue);\r\n                this.emitEvent(\"attach\", { entity: stateValue, key: key });\r\n            }\r\n            else if (oldValue === stateValue) {\r\n                // do nothing\r\n            }\r\n            else {\r\n                oldValue.store = undefined;\r\n                this.emitEvent(\"detach\", { entity: oldValue, key: key });\r\n                this.entities.set(key, stateValue);\r\n                this.emitEvent(\"attach\", { entity: stateValue, key: key });\r\n            }\r\n            return oldValue;\r\n        }\r\n        else {\r\n            return stateValue;\r\n        }\r\n    }\r\n    detach(key) {\r\n        const oldValue = this.entities.get(key);\r\n        if (oldValue === undefined) {\r\n            // do nothing\r\n        }\r\n        else {\r\n            oldValue.store = undefined;\r\n            this.emitEvent(\"detach\", { entity: oldValue, key: key });\r\n        }\r\n    }\r\n    // public emitValueChanged(msg: string, stateValue?: IDSStateValue<Value>, properties?: Set<keyof Value>): void {\r\n    //     super.emitValueChanged(msg, stateValue, properties);\r\n    //     if (stateValue !== undefined) {\r\n    //         this.dirtyEntities.push({ stateValue, properties });\r\n    //     }\r\n    // }\r\n    listenEventAttach(msg, callback) {\r\n        return this.listenEvent(msg, \"attach\", callback);\r\n    }\r\n    listenEventValue(msg, callback) {\r\n        return this.listenEvent(msg, \"value\", callback);\r\n    }\r\n    listenEventDetach(msg, callback) {\r\n        return this.listenEvent(msg, \"detach\", callback);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSMapStore.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSObjectStore.ts":
/*!**************************************************!*\
  !*** ./libs/dependingState/src/DSObjectStore.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSObjectStore\": () => (/* binding */ DSObjectStore)\n/* harmony export */ });\n/* harmony import */ var _DSValueStore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DSValueStore */ \"./libs/dependingState/src/DSValueStore.ts\");\n\r\nclass DSObjectStore extends _DSValueStore__WEBPACK_IMPORTED_MODULE_0__.DSValueStore {\r\n    constructor(storeName, stateValue, configuration) {\r\n        super(storeName, configuration);\r\n        this.stateValue = stateValue;\r\n        stateValue.setStore(this);\r\n    }\r\n    getEntities() {\r\n        return [{ key: \"stateValue\", stateValue: this.stateValue }];\r\n    }\r\n    listenEventValue(msg, callback) {\r\n        return this.listenEvent(msg, \"value\", callback);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSObjectStore.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSPropertiesChanged.ts":
/*!********************************************************!*\
  !*** ./libs/dependingState/src/DSPropertiesChanged.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSPropertiesChanged\": () => (/* binding */ DSPropertiesChanged),\n/* harmony export */   \"getPropertiesChanged\": () => (/* binding */ getPropertiesChanged),\n/* harmony export */   \"getPropertiesSet\": () => (/* binding */ getPropertiesSet),\n/* harmony export */   \"hasChangedProperty\": () => (/* binding */ hasChangedProperty)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ \"./libs/dependingState/src/index.ts\");\n\r\nconst cache = [];\r\nfunction getPropertiesSet(keys) {\r\n    return new Set(keys);\r\n}\r\nfunction getPropertiesChanged(that) {\r\n    const result = cache.pop();\r\n    if (result === undefined) {\r\n        return new DSPropertiesChanged(that);\r\n    }\r\n    else {\r\n        result.instance = that;\r\n        return result;\r\n    }\r\n}\r\nclass DSPropertiesChanged {\r\n    constructor(instance) {\r\n        this.instance = instance;\r\n        this.properties = new Set();\r\n    }\r\n    add(key) {\r\n        this.properties.add(key);\r\n    }\r\n    setIf(key, value, fnIsEqual) {\r\n        const isEqual = ((fnIsEqual === undefined)\r\n            ? (this.instance.value[key] === value)\r\n            : (fnIsEqual(this.instance.value[key], value)));\r\n        if (isEqual) {\r\n            // skip\r\n            return false;\r\n        }\r\n        else {\r\n            this.instance.value[key] = value;\r\n            this.add(key);\r\n            return true;\r\n        }\r\n    }\r\n    get hasChanged() {\r\n        return this.properties.size > 0;\r\n    }\r\n    giveBack() {\r\n        this.instance = null;\r\n        this.properties.clear();\r\n        cache.push(this);\r\n    }\r\n    valueChangedIfNeeded(msg) {\r\n        if (this.properties.size === 0) {\r\n            this.instance = null;\r\n            cache.push(this);\r\n            return false;\r\n        }\r\n        else {\r\n            const instance = this.instance;\r\n            this.instance = null;\r\n            if (___WEBPACK_IMPORTED_MODULE_0__.dsLog.isEnabled(\"valueChangedIfNeeded\")) {\r\n                ___WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSPropertiesChanged\", \"valueChangedIfNeeded\", msg);\r\n            }\r\n            instance.valueChanged(msg, this.properties);\r\n            return true;\r\n        }\r\n    }\r\n    toString() {\r\n        return Array.from(this.properties.keys()).join(\", \");\r\n    }\r\n}\r\nfunction hasChangedProperty(properties, property1, property2, property3, property4) {\r\n    return ((properties === undefined)\r\n        || ((property1 === undefined) || (properties.has(property1)))\r\n        || ((property2 === undefined) || (properties.has(property2)))\r\n        || ((property3 === undefined) || (properties.has(property3)))\r\n        || ((property4 === undefined) || (properties.has(property4))));\r\n}\r\n//\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSPropertiesChanged.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSStateValue.ts":
/*!*************************************************!*\
  !*** ./libs/dependingState/src/DSStateValue.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSStateValue\": () => (/* binding */ DSStateValue),\n/* harmony export */   \"stateValue\": () => (/* binding */ stateValue)\n/* harmony export */ });\n/* harmony import */ var _DSUIStateValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DSUIStateValue */ \"./libs/dependingState/src/DSUIStateValue.ts\");\n/* harmony import */ var _DSLog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DSLog */ \"./libs/dependingState/src/DSLog.ts\");\n\r\n\r\nclass DSStateValue {\r\n    constructor(value) {\r\n        this._value = value;\r\n        this.store = undefined;\r\n        this._stateVersion = 1;\r\n        this.uiStateValue = undefined;\r\n    }\r\n    get stateVersion() {\r\n        return this._stateVersion;\r\n    }\r\n    set stateVersion(value) {\r\n        this._stateVersion = value;\r\n        //dsLog.infoACME(\"DS\", \"DSStateValue\", \"stateVersion\", this._value);\r\n    }\r\n    get value() {\r\n        return this._value;\r\n    }\r\n    set value(v) {\r\n        this._value = v;\r\n        this.valueChanged(\"value\", undefined);\r\n    }\r\n    valueChanged(msg, properties) {\r\n        if (this.store !== undefined) {\r\n            this.stateVersion = this.store.getNextStateVersion(this.stateVersion);\r\n            this.store.emitValueChanged(msg ?? \"valueChanged\", this, properties);\r\n            this.store.emitEvent(\"value\", { entity: this, properties: properties });\r\n        }\r\n        if (this.uiStateValue !== undefined) {\r\n            if (this.store === undefined) {\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_1__.dsLog.debugACME(\"DS\", \"DSStateValue\", \"valueChanged\", \"store is undefined\");\r\n                this.uiStateValue.triggerUIUpdate(this.stateVersion);\r\n            }\r\n            else {\r\n                this.store.emitUIUpdate(this.uiStateValue);\r\n            }\r\n        }\r\n    }\r\n    getUIStateValue() {\r\n        if (this.uiStateValue === undefined) {\r\n            return this.uiStateValue = new _DSUIStateValue__WEBPACK_IMPORTED_MODULE_0__.DSUIStateValue(this);\r\n        }\r\n        else {\r\n            return this.uiStateValue;\r\n        }\r\n    }\r\n    setStore(store) {\r\n        if (this.store === undefined) {\r\n            this.store = store;\r\n            this.stateVersion = store.getNextStateVersion(this.stateVersion);\r\n            return true;\r\n        }\r\n        else if (this.store === store) {\r\n            // ignore\r\n            return false;\r\n        }\r\n        else {\r\n            throw new Error(\"store already set.\");\r\n        }\r\n    }\r\n    getViewProps() {\r\n        return this.getUIStateValue().getViewProps();\r\n    }\r\n    emitUIUpdate() {\r\n        if (this.uiStateValue !== undefined) {\r\n            if (this.store === undefined) {\r\n                this.uiStateValue.triggerUIUpdate(this.stateVersion);\r\n            }\r\n            else {\r\n                this.store.emitUIUpdate(this.uiStateValue);\r\n            }\r\n        }\r\n    }\r\n    triggerUIUpdate(stateVersion) {\r\n        if (this.uiStateValue === undefined) {\r\n            // ignore\r\n        }\r\n        else {\r\n            return this.uiStateValue.triggerUIUpdate(stateVersion);\r\n        }\r\n    }\r\n    get triggerScheduled() {\r\n        if (this.uiStateValue === undefined) {\r\n            return false;\r\n        }\r\n        else {\r\n            return this.uiStateValue.triggerScheduled;\r\n        }\r\n    }\r\n    set triggerScheduled(value) {\r\n        if (this.uiStateValue === undefined) {\r\n        }\r\n        else {\r\n            this.uiStateValue.triggerScheduled = value;\r\n        }\r\n    }\r\n}\r\nfunction stateValue(value) {\r\n    return new DSStateValue(value);\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSStateValue.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSStateValueSelf.ts":
/*!*****************************************************!*\
  !*** ./libs/dependingState/src/DSStateValueSelf.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSStateValueSelf\": () => (/* binding */ DSStateValueSelf)\n/* harmony export */ });\n/* harmony import */ var _DSUIStateValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DSUIStateValue */ \"./libs/dependingState/src/DSUIStateValue.ts\");\n/* harmony import */ var _DSLog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DSLog */ \"./libs/dependingState/src/DSLog.ts\");\n\r\n\r\nclass DSStateValueSelf {\r\n    constructor() {\r\n        this.store = undefined;\r\n        this.stateVersion = 1;\r\n        this.uiStateValue = undefined;\r\n    }\r\n    get value() {\r\n        return this;\r\n    }\r\n    valueChanged(msg, properties) {\r\n        if (this.store !== undefined) {\r\n            this.stateVersion = this.store.getNextStateVersion(this.stateVersion);\r\n            this.store.emitValueChanged(msg ?? \"valueChanged\", this, properties);\r\n            this.store.emitEvent(\"value\", { entity: this, properties: properties });\r\n        }\r\n        if (this.uiStateValue !== undefined) {\r\n            if (this.store === undefined) {\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_1__.dsLog.debugACME(\"DS\", \"DSStateValueSelf\", \"valueChanged\", \"store is undefined\");\r\n                this.uiStateValue.triggerUIUpdate(this.stateVersion);\r\n            }\r\n            else {\r\n                this.store.emitUIUpdate(this.uiStateValue);\r\n            }\r\n        }\r\n    }\r\n    getUIStateValue() {\r\n        if (this.uiStateValue === undefined) {\r\n            return this.uiStateValue = new _DSUIStateValue__WEBPACK_IMPORTED_MODULE_0__.DSUIStateValue(this);\r\n        }\r\n        else {\r\n            return this.uiStateValue;\r\n        }\r\n    }\r\n    setStore(store) {\r\n        if (this.store === undefined) {\r\n            this.store = store;\r\n            this.stateVersion = store.getNextStateVersion(this.stateVersion);\r\n            return true;\r\n        }\r\n        else if (this.store === store) {\r\n            // ignore\r\n            return false;\r\n        }\r\n        else {\r\n            throw new Error(\"store already set.\");\r\n        }\r\n    }\r\n    getViewProps() {\r\n        return this.getUIStateValue().getViewProps();\r\n    }\r\n    emitUIUpdate() {\r\n        if (this.uiStateValue !== undefined) {\r\n            if (this.store === undefined) {\r\n                this.uiStateValue.triggerUIUpdate(this.stateVersion);\r\n            }\r\n            else {\r\n                this.store.emitUIUpdate(this.uiStateValue);\r\n            }\r\n        }\r\n    }\r\n    triggerUIUpdate(stateVersion) {\r\n        if (this.uiStateValue === undefined) {\r\n            // ignore\r\n        }\r\n        else {\r\n            return this.uiStateValue.triggerUIUpdate(stateVersion);\r\n        }\r\n    }\r\n    get triggerScheduled() {\r\n        if (this.uiStateValue === undefined) {\r\n            return false;\r\n        }\r\n        else {\r\n            return this.uiStateValue.triggerScheduled;\r\n        }\r\n    }\r\n    set triggerScheduled(value) {\r\n        if (this.uiStateValue === undefined) {\r\n        }\r\n        else {\r\n            this.uiStateValue.triggerScheduled = value;\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSStateValueSelf.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSStoreBuilder.ts":
/*!***************************************************!*\
  !*** ./libs/dependingState/src/DSStoreBuilder.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSStoreAction\": () => (/* binding */ DSStoreAction),\n/* harmony export */   \"DSStoreBuilder\": () => (/* binding */ DSStoreBuilder),\n/* harmony export */   \"storeBuilder\": () => (/* binding */ storeBuilder)\n/* harmony export */ });\n/* harmony import */ var _DSLog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DSLog */ \"./libs/dependingState/src/DSLog.ts\");\n\r\nfunction storeBuilder(storeName) {\r\n    return new DSStoreBuilder(storeName);\r\n}\r\nclass DSStoreBuilder {\r\n    constructor(storeName) {\r\n        this.storeName = storeName;\r\n        this.actions = new Map();\r\n        this.valueStore = undefined;\r\n    }\r\n    createAction(event) {\r\n        const result = new DSStoreAction(event, this.storeName);\r\n        const key = `${this.storeName}/${event}`;\r\n        if (this.actions.has(key)) {\r\n            throw new Error(`DS createAction event with that name already created. ${key}.`);\r\n        }\r\n        this.actions.set(key, result);\r\n        if (this.valueStore !== undefined) {\r\n            result.bindValueStore(this.valueStore);\r\n        }\r\n        return result;\r\n    }\r\n    bindValueStore(valueStore) {\r\n        this.valueStore = valueStore;\r\n        for (const action of this.actions.values()) {\r\n            _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.debugACME(\"DS\", \"DSStoreBuilder\", \"bindValueStore\", `${action.storeName}/${action.event}`);\r\n            action.bindValueStore(valueStore);\r\n        }\r\n    }\r\n}\r\nclass DSStoreAction {\r\n    constructor(event, storeName) {\r\n        this.event = event;\r\n        this.storeName = storeName;\r\n    }\r\n    // TODO would it be better to create a DSBoundStoreAction?\r\n    bindValueStore(valueStore) {\r\n        if (this.storeName !== valueStore.storeName) {\r\n            throw new Error(\"wrong IDSValueStore\");\r\n        }\r\n        this.valueStore = valueStore;\r\n    }\r\n    /**\r\n     * add the callback to the event. if the event is emitted (emitEvent) all callback are invoked.\r\n     * @param msg this message is shown in the console\r\n     * @param callback this function is called\r\n     * @returns a function that removes the event\r\n     * @throws throw an Error if the store-constructor doesn't call theStoresBuilder.bindValueStore(this)\r\n     */\r\n    listenEvent(msg, callback) {\r\n        if (this.valueStore === undefined) {\r\n            throw new Error(`DS DSStoreAction.listenEvent valueStore is not set ${this.storeName} - Did you call theStore's-Builder.bindValueStore(this) in the constructor?`);\r\n        }\r\n        else {\r\n            if (!msg) {\r\n                msg = `${this.storeName}/${this.event}`;\r\n            }\r\n            return this.valueStore.listenEvent(msg, this.event, callback);\r\n        }\r\n    }\r\n    /**\r\n     * emit the event\r\n     * @param payload the payload\r\n     */\r\n    emitEvent(payload) {\r\n        if (this.valueStore === undefined) {\r\n            throw new Error(`DS DSStoreAction.emitEvent valueStore is not set ${this.storeName} - Did you call theStore's-Builder.bindValueStore(this) in the constructor?`);\r\n        }\r\n        else {\r\n            this.valueStore.emitEvent(this.event, payload);\r\n        }\r\n    }\r\n    /**\r\n    * emit the event - if needed process will be called\r\n    * @param msg\r\n    * @param payload the payload\r\n    */\r\n    emitEventAndProcess(msg, payload) {\r\n        const valueStore = this.valueStore;\r\n        const storeManager = this.valueStore?.storeManager;\r\n        if ((valueStore === undefined) || (storeManager === undefined)) {\r\n            throw new Error(`DS DSStoreAction.emitEvent valueStore is not set ${this.storeName} - Did you call theStore's-Builder.bindValueStore(this) in the constructor?`);\r\n        }\r\n        else {\r\n            if (storeManager.isProcessing === 0) {\r\n                if (this.valueStore.hasEventHandlersFor(this.event)) {\r\n                    storeManager.process(msg, () => {\r\n                        valueStore.emitEvent(this.event, payload);\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                valueStore.emitEvent(this.event, payload);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSStoreBuilder.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSStoreManager.ts":
/*!***************************************************!*\
  !*** ./libs/dependingState/src/DSStoreManager.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSStoreManager\": () => (/* binding */ DSStoreManager)\n/* harmony export */ });\n/* harmony import */ var _DSLog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DSLog */ \"./libs/dependingState/src/DSLog.ts\");\n/* harmony import */ var _PromiseHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PromiseHelper */ \"./libs/dependingState/src/PromiseHelper.ts\");\n\r\n\r\nclass DSStoreManager {\r\n    constructor() {\r\n        this.nextStateVersion = 1;\r\n        this.shouldIncrementStateVersion = false;\r\n        this.arrValueStores = [];\r\n        this.events = [];\r\n        this.isProcessing = 0;\r\n        this.arrUIStateValue = [];\r\n        this.lastPromise = [];\r\n        this.isupdateRegisteredEventsDone = false;\r\n        this.mapValueStoreInternal = new Map();\r\n        this.timeInProcess = 0;\r\n        this.storeManagerState = 0;\r\n        this.enableTiming = false;\r\n        this.isDirty = true;\r\n        this.warnUnlistenEvents = false;\r\n        this.warnEventsOutOfProcess = false;\r\n    }\r\n    /**\r\n     * gets the (global) next stateVersion. within procsess() this value will be increased.\r\n     * @param stateVersion\r\n     */\r\n    getNextStateVersion(stateVersion) {\r\n        this.shouldIncrementStateVersion = true;\r\n        return this.nextStateVersion;\r\n    }\r\n    /**\r\n     * attach the store to the storeManager. The order of the attachs defines the order of store.processDirty is called.\r\n     * @param valueStore the store to attach\r\n     * @returns this\r\n     */\r\n    attach(valueStore) {\r\n        if (this.storeManagerState === 0) {\r\n            this.storeManagerState = 1;\r\n        }\r\n        else if (this.storeManagerState === 1) {\r\n            // OK\r\n        }\r\n        else {\r\n            throw new Error(`storeManagerState=${this.storeManagerState} has an unexpected value;`);\r\n        }\r\n        const valueStoreInternal = valueStore;\r\n        this.arrValueStores = this.arrValueStores.concat([valueStoreInternal]);\r\n        this.mapValueStoreInternal.set(valueStoreInternal.storeName, valueStoreInternal);\r\n        valueStore.storeManager = this;\r\n        return this;\r\n    }\r\n    /**\r\n     * get the store by the storename.\r\n     * @param storeName the name of the store\r\n     * @returns the store or undefined if not found.\r\n     */\r\n    getValueStore(storeName) {\r\n        return this.mapValueStoreInternal.get(storeName);\r\n    }\r\n    /**\r\n     * initialize the storeManager and stores. Call this after you call forall stores storeManager.attach;\r\n     * initialize invoke postAttach in all stores.\r\n     * @returns this\r\n     */\r\n    initialize(fnInitializeStore, fnBoot) {\r\n        if (this.storeManagerState === 1) {\r\n            this.storeManagerState = 2;\r\n        }\r\n        else if (this.storeManagerState === 0) {\r\n            throw new Error(`storeManagerState=0 has an unexpected value. Did you call all stores.attach?`);\r\n        }\r\n        else {\r\n            throw new Error(`storeManagerState=${this.storeManagerState} has an unexpected value;`);\r\n        }\r\n        if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n            _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSStoreManager\", \"initialize\", \"\");\r\n        }\r\n        // initializeStore\r\n        for (const valueStore of this.arrValueStores) {\r\n            valueStore.initializeStore(this);\r\n        }\r\n        if (fnInitializeStore !== undefined) {\r\n            fnInitializeStore();\r\n        }\r\n        if (this.storeManagerState === 2) {\r\n            this.storeManagerState = 3;\r\n        }\r\n        else {\r\n            throw new Error(`storeManagerState=${this.storeManagerState} has an unexpected value;`);\r\n        }\r\n        this.isupdateRegisteredEventsDone = false;\r\n        this.updateRegisteredEvents();\r\n        this.process(\"boot\", () => {\r\n            for (const valueStore of this.arrValueStores) {\r\n                valueStore.initializeBoot();\r\n            }\r\n            if (fnBoot !== undefined) {\r\n                fnBoot();\r\n            }\r\n        });\r\n        return this;\r\n    }\r\n    resetRegisteredEvents() {\r\n        if (this.isupdateRegisteredEventsDone) {\r\n            this.isupdateRegisteredEventsDone = false;\r\n            if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSStoreManager\", \"resetRegisteredEvents\", \"\");\r\n            }\r\n        }\r\n    }\r\n    updateRegisteredEvents() {\r\n        if (this.isupdateRegisteredEventsDone) {\r\n            return;\r\n        }\r\n        if (this.storeManagerState === 3) {\r\n            this.storeManagerState = 4;\r\n        }\r\n        else if (this.storeManagerState === 4) {\r\n            //\r\n        }\r\n        else if (this.storeManagerState === 0) {\r\n            throw new Error(`storeManagerState=0 has an unexpected value. Did you call all stores.attach?`);\r\n        }\r\n        else if (this.storeManagerState === 1) {\r\n            throw new Error(`storeManagerState=1 has an unexpected value. Did you call all storeManager.initialize?`);\r\n        }\r\n        else {\r\n            throw new Error(`storeManagerState=${this.storeManagerState} has an unexpected value;`);\r\n        }\r\n        {\r\n            if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.info(\"DS DSStoreManager updateRegisteredEvents\");\r\n            }\r\n            this.isupdateRegisteredEventsDone = true;\r\n            const mapVS = new Map();\r\n            for (const valueStore of this.arrValueStores) {\r\n                const valueStoreInternal = valueStore;\r\n                if (mapVS.has(valueStoreInternal.storeName)) {\r\n                    _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.errorACME(\"DS\", \"DSStoreManager\", \"updateRegisteredEvents\", valueStoreInternal.storeName, \"dupplicate name\");\r\n                }\r\n                else {\r\n                    mapVS.set(valueStoreInternal.storeName, valueStoreInternal);\r\n                }\r\n                valueStoreInternal.initializeRegisteredEvents();\r\n            }\r\n            this.mapValueStoreInternal = mapVS;\r\n            for (const valueStore of this.arrValueStores) {\r\n                const valueStoreInternal = valueStore;\r\n                valueStoreInternal.validateRegisteredEvents();\r\n            }\r\n            if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                for (const valueStore of this.arrValueStores) {\r\n                    const valueStoreInternal = valueStore;\r\n                    if (valueStoreInternal.mapEventHandlers.size === 0) {\r\n                        _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.info(`DS DSStoreManager updateRegisteredEvents events ${valueStore.storeName} -> %`);\r\n                    }\r\n                    else {\r\n                        const eventNames = Array.from(valueStoreInternal.mapEventHandlers.keys()).sort((a, b) => a.localeCompare(b)).join(\", \");\r\n                        _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.info(`DS DSStoreManager updateRegisteredEvents events ${valueStore.storeName} -> ${eventNames}`);\r\n                    }\r\n                    {\r\n                        if ((valueStoreInternal.arrCleanedUpRelated || []).length === 0) {\r\n                            _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.info(`DS DSStoreManager updateRegisteredEvents dirtyRelated ${valueStore.storeName} -> %`);\r\n                        }\r\n                        else {\r\n                            const dirtyRelatedNames = (valueStoreInternal.arrCleanedUpRelated || []).map(r => `${r.msg} @ ${r.valueStore.storeName}`).join(\", \");\r\n                            _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.info(`DS DSStoreManager updateRegisteredEvents dirtyRelated ${valueStore.storeName} -> ${dirtyRelatedNames}`);\r\n                        }\r\n                    }\r\n                    {\r\n                        if ((valueStoreInternal.arrCleanedUpHandler || []).length === 0) {\r\n                            _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.info(`DS DSStoreManager updateRegisteredEvents dirtyHandlers ${valueStore.storeName} -> %`);\r\n                        }\r\n                        else {\r\n                            const dirtyNames = (valueStoreInternal.arrCleanedUpHandler || []).map(r => r.msg).join(\", \");\r\n                            _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.info(`DS DSStoreManager updateRegisteredEvents dirtyHandlers ${valueStore.storeName} -> ${dirtyNames}`);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    emitUIUpdate(uiStateValue) {\r\n        if (uiStateValue.triggerScheduled === false) {\r\n            uiStateValue.triggerScheduled = true;\r\n            this.arrUIStateValue.push(uiStateValue);\r\n            if (this.isProcessing === 0) {\r\n                if (this.warnEventsOutOfProcess) {\r\n                    _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.warnACME(\"DS\", \"DSStoreManager\", \"emitUIUpdate\", \"%\", \"called out of process\");\r\n                }\r\n                this.process(\"emitUIUpdate\");\r\n            }\r\n        }\r\n    }\r\n    emitEvent(event) {\r\n        if (this.storeManagerState === 2 || this.storeManagerState === 3) {\r\n            this.events.push(event);\r\n        }\r\n        else {\r\n            if (this.isupdateRegisteredEventsDone) {\r\n                const valueStoreInternal = this.mapValueStoreInternal.get(event.storeName);\r\n                if (valueStoreInternal === undefined) {\r\n                    if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                        _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.warn(`DS emitEvent no such store ${event.storeName}/${event.event}`);\r\n                    }\r\n                    return;\r\n                }\r\n                const arrEventHandlers = valueStoreInternal.mapEventHandlers.get(event.event);\r\n                if (arrEventHandlers === undefined || arrEventHandlers.length === 0) {\r\n                    if ((event.event === \"attach\") || (event.event === \"detach\") || (event.event === \"value\")) {\r\n                        // no message\r\n                    }\r\n                    else {\r\n                        debugger;\r\n                        _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.warn(`DS emitEvent no eventHandler for event ${event.storeName}/${event.event} defined.`);\r\n                    }\r\n                    return;\r\n                }\r\n            }\r\n            this.events.push(event);\r\n            if (this.isProcessing === 0) {\r\n                if (this.warnEventsOutOfProcess && _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                    _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.warnACME(\"DS\", \"DSStoreManager\", \"emitEvent\", `${event.storeName}/${event.event}`, \"called out of process\");\r\n                }\r\n                return this.process(\"immediately from emitEvent\");\r\n            }\r\n            else {\r\n                if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                    _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSStoreManager\", \"emitEvent\", `${event.storeName}/${event.event}`, \"queued\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /*\r\n    public async processAsync(msg?: string, fn?: () => DSEventHandlerResult): Promise<void> {\r\n        let dt: number = 0;\r\n        const enableTiming = this.enableTiming && dsLog.enabled && (this.isProcessing === 0);\r\n        if (enableTiming) {\r\n            dt = (window.performance) ? performance.now() : Date.now();\r\n        }\r\n        this.updateRegisteredEvents();\r\n        this.isProcessing++;\r\n        if (dsLog.enabled) {\r\n            dsLog.group(`DS DSStoreManager processAsync ${(msg || \"\")} (${this.isProcessing})`);\r\n        }\r\n        try {\r\n            if (fn) {\r\n                this.incrementStateVersion();\r\n                const pFn = fn();\r\n                if (pFn && typeof pFn.then === \"function\") {\r\n                    for (let watchdog = 0; (watchdog == 0) || ((this.events.length > 0) && (watchdog < 100)); watchdog++) {\r\n                        this.processOneLoop();\r\n                    }\r\n                    await pFn;\r\n                }\r\n            }\r\n            for (let watchdog = 0; (watchdog == 0) || ((this.events.length > 0) && (watchdog < 100)); watchdog++) {\r\n                this.processOneLoop();\r\n            }\r\n\r\n        } finally {\r\n            this.isProcessing--;\r\n\r\n            if (dsLog.enabled) {\r\n                dsLog.groupEnd();\r\n            }\r\n            if (enableTiming) {\r\n                const time = (window.performance) ? (performance.now() - dt) : (Date.now() - dt);\r\n                this.timeInProcess += time;\r\n                dsLog.infoACME(\"DS\", \"DSStoreManager\", \"processAsync\", `current:${Math.round(time * 1000) / 10} sum:${Math.round(this.timeInProcess * 1000) / 10}`, (window.performance) ? \"s timing\" : \"ms timing\");\r\n            }\r\n        }\r\n    }\r\n    */\r\n    process(msg, fn) {\r\n        let dt = 0;\r\n        const enableTiming = this.enableTiming && _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled; //&& (this.isProcessing === 0);\r\n        if (enableTiming) {\r\n            dt = (window.performance) ? performance.now() : Date.now();\r\n        }\r\n        this.updateRegisteredEvents();\r\n        this.isProcessing++;\r\n        if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n            _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.group(`DS DSStoreManager process ${(msg || \"\")} (${this.isProcessing})`);\r\n        }\r\n        try {\r\n            if (fn) {\r\n                this.incrementStateVersion();\r\n                const pFn = fn();\r\n                if (pFn && typeof pFn.then === \"function\") {\r\n                    for (let watchdog = 0; (watchdog == 0) || ((this.events.length > 0) && (watchdog < 100)); watchdog++) {\r\n                        this.processOneLoop();\r\n                    }\r\n                    this.addRemoveLastPromise(pFn);\r\n                    return pFn;\r\n                }\r\n            }\r\n            for (let watchdog = 0; (watchdog == 0) || ((this.events.length > 0) && (watchdog < 100)); watchdog++) {\r\n                this.processOneLoop();\r\n            }\r\n        }\r\n        finally {\r\n            this.isProcessing--;\r\n            if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.groupEnd();\r\n            }\r\n            if (enableTiming) {\r\n                const time = (window.performance) ? (performance.now() - dt) : (Date.now() - dt);\r\n                this.timeInProcess += time;\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSStoreManager\", \"process\", `current:${Math.round(time * 1000) / 10} sum:${Math.round(this.timeInProcess * 1000) / 10}`, (window.performance) ? \"s timing\" : \"ms timing\");\r\n            }\r\n        }\r\n    }\r\n    addRemoveLastPromise(pLast) {\r\n        const thisPromise = pLast;\r\n        this.lastPromise.push(pLast);\r\n        pLast.finally(() => {\r\n            const idx = this.lastPromise.indexOf(thisPromise);\r\n            if (0 <= idx) {\r\n                this.lastPromise.splice(idx, 1);\r\n            }\r\n            this.processDirty();\r\n            this.processUIUpdates();\r\n        });\r\n        return pLast;\r\n    }\r\n    async processAsyncAllSettled() {\r\n        if (this.lastPromise.length > 0) {\r\n            const promises = this.lastPromise;\r\n            this.lastPromise = [];\r\n            await Promise.allSettled(promises);\r\n        }\r\n    }\r\n    processOneLoop() {\r\n        this.incrementStateVersion();\r\n        const logGroup = _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled;\r\n        if (logGroup) {\r\n            _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.group(`loop ${this.nextStateVersion}`);\r\n        }\r\n        try {\r\n            while (this.events.length > 0) {\r\n                const event = this.events.splice(0, 1)[0];\r\n                this.processOneEvent(event);\r\n            }\r\n            {\r\n                this.processDirty();\r\n                this.processUIUpdates();\r\n            }\r\n            return;\r\n        }\r\n        finally {\r\n            if (logGroup) {\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.groupEnd();\r\n            }\r\n        }\r\n    }\r\n    processOneEvent(event) {\r\n        const valueStoreInternal = this.mapValueStoreInternal.get(event.storeName);\r\n        if (valueStoreInternal === undefined) {\r\n            if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.logEnabled) {\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.warn(`DS DSStoreManager processOneEvent no such store ${event.storeName}/${event.event}`);\r\n            }\r\n            return;\r\n        }\r\n        else {\r\n            const arrEventHandlers = valueStoreInternal.mapEventHandlers.get(event.event);\r\n            if ((arrEventHandlers !== undefined) && (arrEventHandlers.length > 0)) {\r\n                this.shouldIncrementStateVersion = true;\r\n                try {\r\n                    for (const eventHandler of arrEventHandlers) {\r\n                        _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSStoreManager\", \"processOneEvent\", eventHandler.msg);\r\n                        const p = eventHandler.handler(event);\r\n                        // does the eventHandler return a promise?\r\n                        if (p && typeof p.then === \"function\") {\r\n                            const cp = (0,_PromiseHelper__WEBPACK_IMPORTED_MODULE_1__.catchLog)(\"processOneEvent\", p);\r\n                            this.addRemoveLastPromise(cp);\r\n                        }\r\n                    }\r\n                }\r\n                catch (reason) {\r\n                    _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSStoreManager\", \"processOneEvent-failed\", `${event.storeName}/${event.event}`, `${reason} ${reason.stack}`);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    processDirty() {\r\n        if (this.isDirty) {\r\n            this.isDirty = false;\r\n            for (const valueStore of this.arrValueStores) {\r\n                if (valueStore.isDirty) {\r\n                    if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                        _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSStoreManager\", \"processDirty\", valueStore.storeName, \"isDirty\");\r\n                    }\r\n                    const processDirtyResult = valueStore.processDirty();\r\n                    valueStore.postProcessDirty(processDirtyResult);\r\n                    if (processDirtyResult) {\r\n                        this.shouldIncrementStateVersion = true;\r\n                    }\r\n                }\r\n                else {\r\n                    // TODO swtich for log\r\n                    // if (dsLog.enabled) {\r\n                    //     dsLog.infoACME(\"DS\", \"DSStoreManager\", \"processDirty\", valueStore.storeName, \"is clean\");\r\n                    // }        \r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // TODO swtich for log\r\n            // if (dsLog.enabled) {\r\n            //     dsLog.debugACME(\"DS\", \"DSStoreManager\", \"processDirty\", \"completely clean.\");\r\n            // }\r\n        }\r\n    }\r\n    processUIUpdates() {\r\n        if (this.arrUIStateValue.length > 0) {\r\n            if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSStoreManager\", \"processUIUpdates\", `${this.arrUIStateValue.length}`);\r\n            }\r\n            this.shouldIncrementStateVersion = true;\r\n            const arrUIStateValue = this.arrUIStateValue;\r\n            this.arrUIStateValue = [];\r\n            for (const uiStateValue of arrUIStateValue) {\r\n                uiStateValue.triggerUIUpdate(this.nextStateVersion);\r\n            }\r\n        }\r\n    }\r\n    incrementStateVersion() {\r\n        if (this.shouldIncrementStateVersion) {\r\n            this.shouldIncrementStateVersion = false;\r\n            this.nextStateVersion++;\r\n            if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSStoreManager\", \"incrementStateVersion\", `${this.nextStateVersion}`);\r\n            }\r\n        }\r\n    }\r\n    setSelfInGlobal() {\r\n        window.appStoreManager = this;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSStoreManager.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSUIBinder.ts":
/*!***********************************************!*\
  !*** ./libs/dependingState/src/DSUIBinder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSUIBinder\": () => (/* binding */ DSUIBinder),\n/* harmony export */   \"bindUIComponent\": () => (/* binding */ bindUIComponent)\n/* harmony export */ });\nclass DSUIBinder {\r\n    constructor(component, props) {\r\n        this.component = component;\r\n        this.props = props;\r\n        this.state = {\r\n            stateVersion: props.getStateVersion()\r\n        };\r\n        this.arrUnwireStateVersion = [];\r\n        this.add(\"stateVersion\", props);\r\n    }\r\n    add(stateVersionName, nextProps) {\r\n        if (this.state === undefined) {\r\n            throw new Error(`add must be called before getState. ${this.component.constructor.name}.`);\r\n        }\r\n        if (this.arrUnwireStateVersion === undefined) {\r\n            throw new Error(`add must be called before setComponentWillUnmount or getUnbinder.${this.component.constructor.name}.`);\r\n        }\r\n        //this.state![stateVersionName] = nextProps.getStateVersion();\r\n        this.state[stateVersionName] = nextProps.wireStateVersion(this.component, stateVersionName);\r\n        this.arrUnwireStateVersion.push(nextProps.unwireStateVersion);\r\n        return this;\r\n    }\r\n    bindHandleAll() {\r\n        const p = Object.getPrototypeOf(this.component);\r\n        for (const key of Object.getOwnPropertyNames(p)) {\r\n            if (key.startsWith(\"handle\")) {\r\n                // console.log(\"bindHandleAll\", key);\r\n                if (Object.prototype.hasOwnProperty.call(p, key)) {\r\n                    const fn = p[key];\r\n                    if (typeof fn === \"function\") {\r\n                        // console.log(\"bindHandleAll\", key);\r\n                        this.component[key] = fn.bind(this.component);\r\n                    }\r\n                    else {\r\n                        // console.log(\"bindHandleAll not\", key);\r\n                    }\r\n                }\r\n                else {\r\n                    // console.log(\"bindHandleAll not\", key);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    bindHandle(fnName) {\r\n        if (Array.isArray(fnName)) {\r\n            for (const key in fnName) {\r\n                if (Object.prototype.hasOwnProperty.call(this.component, key)) {\r\n                    const fn = this.component[key];\r\n                    if (typeof fn === \"function\") {\r\n                        this.component[key] = fn.bind(this.component);\r\n                    }\r\n                    else {\r\n                        throw new Error(`${key}`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            const fn = this.component[fnName];\r\n            this.component[fnName] = fn.bind(this.component);\r\n        }\r\n        return this;\r\n    }\r\n    setComponentWillUnmount() {\r\n        if (this.state === undefined) {\r\n            throw new Error(`setComponentWillUnmount must be called before getState. ${this.component.constructor.name}.`);\r\n        }\r\n        if (this.arrUnwireStateVersion === undefined) {\r\n            throw new Error(`setComponentWillUnmount or getUnbinder can be called only once.${this.component.constructor.name}.`);\r\n        }\r\n        const arrUnwireStateVersion = this.arrUnwireStateVersion;\r\n        this.arrUnwireStateVersion = undefined;\r\n        const prevComponentWillUnmount = this.component.componentWillUnmount;\r\n        this.component.componentWillUnmount = componentWillUnmountTemplate.bind(undefined, this.component, prevComponentWillUnmount, arrUnwireStateVersion);\r\n        return this;\r\n    }\r\n    getUnbinder() {\r\n        if (this.state === undefined) {\r\n            throw new Error(`getUnbinder must be called before getState.${this.component.constructor.name}.`);\r\n        }\r\n        if (this.arrUnwireStateVersion === undefined) {\r\n            throw new Error(`setComponentWillUnmount or getUnbinder can be called only once.${this.component.constructor.name}.`);\r\n        }\r\n        const arrUnwireStateVersion = this.arrUnwireStateVersion;\r\n        this.arrUnwireStateVersion = undefined;\r\n        const prevComponentWillUnmount = this.component.componentWillUnmount;\r\n        return componentWillUnmountTemplate.bind(undefined, this.component, prevComponentWillUnmount, arrUnwireStateVersion);\r\n    }\r\n    getState() {\r\n        console.log(\"setComponentWillUnmount\", this.component);\r\n        if (this.state === undefined) {\r\n            throw new Error(`getState cannot be called twice. ${this.component.constructor.name}.`);\r\n        }\r\n        if (this.arrUnwireStateVersion !== undefined) {\r\n            throw new Error(`setComponentWillUnmount or getUnbinder must be called before getState.${this.component.constructor.name}.`);\r\n        }\r\n        const result = this.state;\r\n        this.state = undefined;\r\n        return result;\r\n    }\r\n}\r\nfunction bindUIComponent(component, props) {\r\n    return new DSUIBinder(component, props);\r\n}\r\nfunction componentWillUnmountTemplate(component, prevComponentWillUnmount, arrUnwireStateVersion) {\r\n    for (const unwireStateVersion of arrUnwireStateVersion) {\r\n        unwireStateVersion(component);\r\n    }\r\n    if (prevComponentWillUnmount !== undefined) {\r\n        prevComponentWillUnmount.call(component);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSUIBinder.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSUIStateValue.ts":
/*!***************************************************!*\
  !*** ./libs/dependingState/src/DSUIStateValue.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSUIStateValue\": () => (/* binding */ DSUIStateValue)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ \"./libs/dependingState/src/index.ts\");\n\r\nclass DSUIStateValue {\r\n    constructor(stateValue) {\r\n        this.arrComponentStateVersionName = undefined;\r\n        this.stateValue = stateValue;\r\n        this.viewStateVersion = 0;\r\n        this.triggerScheduled = false;\r\n    }\r\n    getViewProps() {\r\n        if (this._ViewProps === undefined) {\r\n            const fnGetRenderProps = (() => {\r\n                return this.stateValue.value;\r\n            });\r\n            const fnWireStateVersion = ((component, stateVersionName) => {\r\n                const csvn = { component: component, stateVersionName: stateVersionName ?? \"stateVersion\" };\r\n                if (this.arrComponentStateVersionName === undefined) {\r\n                    this.arrComponentStateVersionName = csvn;\r\n                }\r\n                else if (Array.isArray(this.arrComponentStateVersionName)) {\r\n                    this.arrComponentStateVersionName.push(csvn);\r\n                }\r\n                else {\r\n                    this.arrComponentStateVersionName = [this.arrComponentStateVersionName, csvn];\r\n                }\r\n                return this.stateValue.stateVersion;\r\n            });\r\n            const fnUnwireStateVersion = ((component) => {\r\n                if (this.arrComponentStateVersionName === undefined) {\r\n                    // done\r\n                }\r\n                else if (Array.isArray(this.arrComponentStateVersionName)) {\r\n                    for (let idx = 0; idx < this.arrComponentStateVersionName.length; idx++) {\r\n                        if (this.arrComponentStateVersionName[idx].component === component) {\r\n                            this.arrComponentStateVersionName.splice(idx, 1);\r\n                            if (this.arrComponentStateVersionName.length === 1) {\r\n                                this.arrComponentStateVersionName = this.arrComponentStateVersionName[0];\r\n                            }\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (this.arrComponentStateVersionName.component === component) {\r\n                        this.arrComponentStateVersionName = undefined;\r\n                    }\r\n                }\r\n            });\r\n            const fnGetStateVersion = (() => {\r\n                return this.stateValue.stateVersion;\r\n            });\r\n            //\r\n            if ((typeof this.stateValue.value.key == \"string\") || (typeof this.stateValue.value.key == \"number\")) {\r\n                this._ViewProps = {\r\n                    getRenderProps: fnGetRenderProps,\r\n                    wireStateVersion: fnWireStateVersion,\r\n                    unwireStateVersion: fnUnwireStateVersion,\r\n                    getStateVersion: fnGetStateVersion,\r\n                    key: this.stateValue.value.key\r\n                };\r\n            }\r\n            else {\r\n                this._ViewProps = {\r\n                    getRenderProps: fnGetRenderProps,\r\n                    wireStateVersion: fnWireStateVersion,\r\n                    unwireStateVersion: fnUnwireStateVersion,\r\n                    getStateVersion: fnGetStateVersion,\r\n                };\r\n            }\r\n        }\r\n        return this._ViewProps;\r\n    }\r\n    triggerUIUpdate(stateVersion) {\r\n        this.triggerScheduled = false;\r\n        // const stateVersion = this.stateValue.stateVersion;\r\n        // if (this.component === undefined) {\r\n        //     //\r\n        // } else {\r\n        //     if (stateVersion === this.viewStateVersion) {\r\n        //         //\r\n        //         dsLog.info(`DSUIStateValue skip update same stateVersion: ${stateVersion}`)\r\n        //     } else {\r\n        this.viewStateVersion = stateVersion;\r\n        const enabled = (___WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled && ___WEBPACK_IMPORTED_MODULE_0__.dsLog.isEnabled(\"triggerUIUpdate\"));\r\n        if (this.arrComponentStateVersionName === undefined) {\r\n            //\r\n            if (enabled) {\r\n                ___WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSUIStateValue\", \"triggerUIUpdate\", \"no component\");\r\n            }\r\n        }\r\n        else if (Array.isArray(this.arrComponentStateVersionName)) {\r\n            for (const componentStateVersionName of this.arrComponentStateVersionName) {\r\n                componentStateVersionName.component.setState({ [componentStateVersionName.stateVersionName]: stateVersion });\r\n                if (enabled) {\r\n                    ___WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSUIStateValue\", \"triggerUIUpdate\", ___WEBPACK_IMPORTED_MODULE_0__.dsLog.convertArg(componentStateVersionName));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.arrComponentStateVersionName.component.setState({ [this.arrComponentStateVersionName.stateVersionName]: stateVersion });\r\n            if (enabled) {\r\n                ___WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSUIStateValue\", \"triggerUIUpdate\", ___WEBPACK_IMPORTED_MODULE_0__.dsLog.convertArg(this.arrComponentStateVersionName));\r\n            }\r\n        }\r\n        //     }\r\n        // }\r\n    }\r\n    /*\r\n        triggerUIUpdate(stateVersion: number): void {\r\n            this.triggerScheduled = false;\r\n            // const stateVersion = this.stateValue.stateVersion;\r\n            // if (this.component === undefined) {\r\n            //     //\r\n            // } else {\r\n            //     if (stateVersion === this.viewStateVersion) {\r\n            //         //\r\n            //         dsLog.info(`DSUIStateValue skip update same stateVersion: ${stateVersion}`)\r\n\r\n            //     } else {\r\n            this.viewStateVersion = stateVersion;\r\n            if (this.componentStateVersionName === undefined) {\r\n                //\r\n            } else if (Array.isArray(this.componentStateVersionName)) {\r\n                for (const component of this.componentStateVersionName) {\r\n                    component.setState({ stateVersion: stateVersion });\r\n                    if (dsLog.enabled) {\r\n                        dsLog.infoACME(\"DS\", \"DSUIStateValue\", \"triggerUIUpdate\", dsLog.convertArg(component));\r\n                    }\r\n                }\r\n            } else {\r\n                this.componentStateVersionName.setState({ stateVersion: stateVersion });\r\n\r\n                if (dsLog.enabled) {\r\n                    dsLog.infoACME(\"DS\", \"DSUIStateValue\", \"triggerUIUpdate\", dsLog.convertArg(this.componentStateVersionName));\r\n                }\r\n            }\r\n            //     }\r\n            // }\r\n        }\r\n    */\r\n    toString() {\r\n        if (typeof this.stateValue.value.toString === \"function\") {\r\n            return this.stateValue.value.toString();\r\n        }\r\n        if (typeof this.stateValue.toString === \"function\") {\r\n            return this.stateValue.toString();\r\n        }\r\n        return `${this.stateValue}`;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSUIStateValue.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSValueChanged.ts":
/*!***************************************************!*\
  !*** ./libs/dependingState/src/DSValueChanged.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSValueChanged\": () => (/* binding */ DSValueChanged)\n/* harmony export */ });\nclass DSValueChanged {\r\n    constructor(next, value, fnIsEqual) {\r\n        this.next = next;\r\n        this.value = value;\r\n        this.fnIsEqual = fnIsEqual;\r\n    }\r\n    setValue(value) {\r\n        if (this.value === undefined) {\r\n            // changed \r\n        }\r\n        else if (this.value === value) {\r\n            // same case T T\r\n            return false;\r\n        }\r\n        else if (this.fnIsEqual !== undefined) {\r\n            if (this.fnIsEqual(this.value, value)) {\r\n                // equal\r\n                return false;\r\n            }\r\n        }\r\n        this.value = value;\r\n        if (this.next !== undefined) {\r\n            this.next(value);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSValueChanged.ts?");

/***/ }),

/***/ "./libs/dependingState/src/DSValueStore.ts":
/*!*************************************************!*\
  !*** ./libs/dependingState/src/DSValueStore.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSValueStore\": () => (/* binding */ DSValueStore)\n/* harmony export */ });\n/* harmony import */ var _DSLog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DSLog */ \"./libs/dependingState/src/DSLog.ts\");\n//IDSStoreManagerInternal \r\n\r\n// State Value extends IDSStateValue<Value> = (Value extends IDSStateValue<Value> ? Value : IDSStateValue<Value>),\r\nclass DSValueStore {\r\n    constructor(storeName, configuration) {\r\n        this.storeName = storeName;\r\n        this.storeManager = undefined;\r\n        this.mapEventHandlers = new Map();\r\n        this._isDirty = false;\r\n        this.stateVersion = 1;\r\n        this.isProcessDirtyConfigured = false;\r\n        this.triggerScheduled = false;\r\n        this.viewStateVersion = 0;\r\n        if (configuration === undefined) {\r\n            this.configuration = {};\r\n        }\r\n        else {\r\n            this.configuration = { ...configuration };\r\n        }\r\n    }\r\n    get isDirty() {\r\n        return this._isDirty;\r\n    }\r\n    /**\r\n     * binds the events/actions from the storeBuilder to this valueStore\r\n     * @param storeBuilder the storeBuilder to bind\r\n     */\r\n    setStoreBuilder(storeBuilder) {\r\n        if (this.storeBuilder !== undefined) {\r\n            throw new Error(`DS storeBuilder is already set ${this.storeName}`);\r\n        }\r\n        this.storeBuilder = storeBuilder;\r\n        storeBuilder.bindValueStore(this);\r\n    }\r\n    /**\r\n     * call all listenDirtyValue, listenCleanedUp, listenCleanedUpRelated and listenEvent.\r\n     */\r\n    initializeStore() {\r\n        this.stateVersion = this.storeManager.getNextStateVersion(0);\r\n        if (this.configuration.initializeStore !== undefined) {\r\n            this.configuration.initializeStore();\r\n        }\r\n    }\r\n    /**\r\n     * called after initializeStore\r\n     */\r\n    initializeRegisteredEvents() {\r\n        this.isProcessDirtyConfigured = this.hasProcessDirtyConfigured();\r\n    }\r\n    /**\r\n     * called after initializeRegisteredEvents\r\n     */\r\n    validateRegisteredEvents() {\r\n        if (this.arrCleanedUpRelated !== undefined) {\r\n            if (!this.isProcessDirtyConfigured) {\r\n                const relatedStoreNames = this.arrCleanedUpRelated.map(i => i.valueStore.storeName).join(\", \");\r\n                throw new Error(`${this.storeName}.processDirty (method or config) is not defined, but listenCleanedUpRelated was called from ${relatedStoreNames}.`);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * called after initializeStore (and after initializeRegisteredEvents)\r\n     */\r\n    initializeBoot() {\r\n        if (this.configuration.initializeBoot !== undefined) {\r\n            this.configuration.initializeBoot();\r\n        }\r\n    }\r\n    hasProcessDirtyConfigured() {\r\n        if (this.configuration.processDirty !== undefined) {\r\n            return true;\r\n        }\r\n        if (!(this.processDirty === DSValueStore.prototype.processDirty)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * gets all entities\r\n     */\r\n    getEntities() {\r\n        return [];\r\n    }\r\n    getNextStateVersion(stateVersion) {\r\n        if (this.storeManager === undefined) {\r\n            return (this.stateVersion = (Math.max(this.stateVersion, stateVersion) + 1));\r\n        }\r\n        else {\r\n            return (this.stateVersion = this.storeManager.getNextStateVersion(stateVersion));\r\n        }\r\n    }\r\n    emitEvent(eventType, payload) {\r\n        const event = {\r\n            storeName: this.storeName,\r\n            event: eventType,\r\n            payload: payload\r\n        };\r\n        let arrEventHandlers = this.mapEventHandlers.get(event.event);\r\n        if ((arrEventHandlers === undefined) || (arrEventHandlers?.length === 0)) {\r\n            if ((this.storeManager !== undefined) && this.storeManager.warnUnlistenEvents) {\r\n                if ((event.event === \"attach\") || (event.event === \"detach\") || (event.event === \"value\")) {\r\n                }\r\n                else {\r\n                    _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.warnACME(\"DS\", \"DSValueStore\", \"emitEvent\", `${this.storeName}/${event.event}`, \"No event registered for listening\");\r\n                }\r\n            }\r\n        }\r\n        else if (this.storeManager === undefined) {\r\n            _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.warnACME(\"DS\", \"DSValueStore\", \"emitEvent\", `${this.storeName}/${event.event}`, \"this.storeManager is undefined\");\r\n            return this.processEvent(event);\r\n        }\r\n        else {\r\n            return this.storeManager.emitEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * returns if any eventhandler is registered for this event\r\n     * @param event the eventname\r\n     */\r\n    hasEventHandlersFor(event) {\r\n        const arrEventHandlers = this.mapEventHandlers.get(event);\r\n        if (arrEventHandlers === undefined) {\r\n            return false;\r\n        }\r\n        else {\r\n            return (arrEventHandlers.length > 0);\r\n        }\r\n    }\r\n    listenEvent(msg, event, callback) {\r\n        if (this.storeManager !== undefined) {\r\n            if (this.storeManager.storeManagerState == 0) {\r\n                throw new Error(`storeManagerState=0 has an unexpected value. Did you call all stores.attach?`);\r\n            }\r\n            else if (this.storeManager.storeManagerState == 1) {\r\n                throw new Error(`storeManagerState=1 has an unexpected value. Did you call within initializeStore()?`);\r\n            }\r\n            else if (this.storeManager.storeManagerState == 2) {\r\n                // OK\r\n            }\r\n            else if (this.storeManager.storeManagerState == 3) {\r\n                throw new Error(`storeManagerState=1 has an unexpected value. Did you call within initializeStore()?`);\r\n            }\r\n            else if (this.storeManager.storeManagerState == 4) {\r\n                throw new Error(`storeManagerState=1 has an unexpected value. Did you call within initializeStore()?`);\r\n            }\r\n            else {\r\n                throw new Error(`storeManagerState=${this.storeManager.storeManagerState} has an unexpected value;`);\r\n            }\r\n        }\r\n        let arrEventHandlers = this.mapEventHandlers.get(event);\r\n        if (arrEventHandlers === undefined) {\r\n            this.mapEventHandlers.set(event, [{ msg: msg, handler: callback }]);\r\n        }\r\n        else {\r\n            this.mapEventHandlers.set(event, arrEventHandlers.concat([{ msg: msg, handler: callback }]));\r\n        }\r\n        this.storeManager?.resetRegisteredEvents();\r\n        return this.unlistenEvent.bind(this, event, callback);\r\n    }\r\n    unlistenEvent(event, callback) {\r\n        let arrEventHandlers = this.mapEventHandlers.get(event);\r\n        if (arrEventHandlers === undefined) {\r\n            // should not be\r\n        }\r\n        else {\r\n            arrEventHandlers = arrEventHandlers.filter(cb => cb.handler !== callback);\r\n            if (arrEventHandlers.length === 0) {\r\n                this.mapEventHandlers.delete(event);\r\n            }\r\n            else {\r\n                this.mapEventHandlers.set(event, arrEventHandlers);\r\n            }\r\n            this.storeManager?.resetRegisteredEvents();\r\n        }\r\n    }\r\n    /**\r\n     * internal\r\n     * @param event\r\n     */\r\n    processEvent(event) {\r\n        let r;\r\n        let result;\r\n        let arrEventHandlers = this.mapEventHandlers.get(event.event);\r\n        if (arrEventHandlers === undefined) {\r\n            // nobody is listening\r\n            if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSValueStore\", \"processEvent\", `${event.storeName}/${event.event}`, \"/nobody is listening\");\r\n            }\r\n        }\r\n        else {\r\n            for (const { msg, handler: callback } of arrEventHandlers) {\r\n                if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                    _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSValueStore\", \"processEvent\", `${event.storeName}/${event.event}`, `/with ${msg}`);\r\n                }\r\n                if (r === undefined) {\r\n                    try {\r\n                        r = callback(event);\r\n                    }\r\n                    catch (reason) {\r\n                        debugger;\r\n                        _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.error(msg, reason);\r\n                    }\r\n                }\r\n                else {\r\n                    r = r.catch((reason) => {\r\n                        debugger;\r\n                        _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.error(msg, reason);\r\n                    }).then(() => { return callback(event); });\r\n                }\r\n            }\r\n        }\r\n        if (r == undefined) {\r\n            return;\r\n        }\r\n        else {\r\n            return r.catch((reason) => {\r\n                debugger;\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.error(reason);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * should be called after a value change - or willbe called from DSPropertiesChanged.valueChangedIfNeeded().\r\n     * calls all callbacks - registed with listenDirtyValue - which can call setDirty if a relevant property was changed.\r\n     * @param stateValue\r\n     * @param properties\r\n     */\r\n    emitValueChanged(msg, stateValue, properties) {\r\n        if ((this.arrValueChangedHandler !== undefined) || (this.isProcessDirtyConfigured)) {\r\n            if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.isEnabled(\"emitValueChanged\")) {\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSValueStore\", \"emitValueChanged\", this.storeName);\r\n            }\r\n            if ((this.arrValueChangedHandler !== undefined)) {\r\n                for (const valueChangedHandler of this.arrValueChangedHandler) {\r\n                    if (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled) {\r\n                        _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSValueStore\", \"emitValueChanged\", valueChangedHandler.msg, \"/dirtyHandler\");\r\n                    }\r\n                    valueChangedHandler.handler(stateValue, properties);\r\n                }\r\n            }\r\n            if (this.isProcessDirtyConfigured) {\r\n                this.setDirty(msg ?? \"emitValueChanged\");\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * register a callback that is called from emitDirtyValue.\r\n     * @param msg the log message is logged before the callback is invoked.\r\n     * @param callback the callback that will be called\r\n     */\r\n    listenValueChanged(msg, callback) {\r\n        if (this.arrValueChangedHandler === undefined) {\r\n            this.arrValueChangedHandler = [{ msg: msg, handler: callback }];\r\n        }\r\n        else {\r\n            this.arrValueChangedHandler.push({ msg: msg, handler: callback });\r\n        }\r\n        return this.unlistenValueChanged.bind(this, callback);\r\n    }\r\n    /**\r\n     * unregister the callback\r\n     * @param callback the callback to unregister\r\n     */\r\n    unlistenValueChanged(callback) {\r\n        if (this.arrValueChangedHandler !== undefined) {\r\n            this.arrValueChangedHandler = this.arrValueChangedHandler.filter((cb) => cb.handler !== callback);\r\n            if (this.arrValueChangedHandler.length === 0) {\r\n                this.arrValueChangedHandler = undefined;\r\n                // this.storeManager?.resetRegisteredEvents();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * set the isDirty flag and DSStoreManager.process will call processDirty\r\n     * @param msg the message is logged if the store was not dirty\r\n     */\r\n    setDirty(msg) {\r\n        if (this._isDirty) {\r\n            return;\r\n        }\r\n        this._isDirty = true;\r\n        if (this.storeManager === undefined) {\r\n            _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.warnACME(\"DS\", \"DSValueStore\", \"setDirty\", this.storeName, \"storeManager is not set.\");\r\n        }\r\n        else {\r\n            this.storeManager.isDirty = true;\r\n            _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSValueStore\", \"setDirty\", this.storeName, msg);\r\n        }\r\n    }\r\n    /**\r\n     *  DSStoreManager.process call this if setDirty was called before\r\n     *  @returns true then emitCleanUp will be called\r\n     */\r\n    processDirty() {\r\n        if (this.configuration.processDirty !== undefined) {\r\n            return this.configuration.processDirty.apply(this);\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * called after processDirty()\r\n     */\r\n    postProcessDirty(processDirtyResult) {\r\n        this._isDirty = false;\r\n        if (processDirtyResult) {\r\n            this.emitCleanedUp();\r\n        }\r\n        else {\r\n            //\r\n        }\r\n    }\r\n    /**\r\n     * would be called if processDirty returns true\r\n     */\r\n    emitCleanedUp() {\r\n        if (this.arrCleanedUpRelated !== undefined) {\r\n            for (const cleanedUpRelated of this.arrCleanedUpRelated) {\r\n                var relatedValueStore = cleanedUpRelated.valueStore;\r\n                relatedValueStore.setDirty(cleanedUpRelated.msg);\r\n            }\r\n        }\r\n        if (this.arrCleanedUpHandler !== undefined) {\r\n            for (const cleanedUpHandler of this.arrCleanedUpHandler) {\r\n                cleanedUpHandler.handler(this);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * register a callback that is (directly) invoked by emitDirty\r\n     * @param msg\r\n     * @param callback\r\n     */\r\n    listenCleanedUp(msg, callback) {\r\n        const cleanedUpHandler = { msg: msg, handler: callback };\r\n        if (this.arrCleanedUpHandler === undefined) {\r\n            this.arrCleanedUpHandler = [cleanedUpHandler];\r\n        }\r\n        else {\r\n            this.arrCleanedUpHandler.push(cleanedUpHandler);\r\n        }\r\n        return this.unlistenCleanedUp.bind(this, callback);\r\n    }\r\n    /**\r\n     * unregister a callback\r\n     * @param callback\r\n     */\r\n    unlistenCleanedUp(callback) {\r\n        if (this.arrCleanedUpHandler !== undefined) {\r\n            this.arrCleanedUpHandler = this.arrCleanedUpHandler.filter((item) => (item.handler !== callback));\r\n            if (this.arrCleanedUpHandler.length === 0) {\r\n                this.arrCleanedUpHandler = undefined;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n      * if this store gets cleanedup (processDirty returns true) the relatedValueStore gets dirty.\r\n      * @param msg\r\n      * @param relatedValueStore\r\n      */\r\n    listenCleanedUpRelated(msg, relatedValueStore) {\r\n        if (this.arrCleanedUpRelated === undefined) {\r\n            this.arrCleanedUpRelated = [];\r\n        }\r\n        const index = this.arrCleanedUpRelated.findIndex((item) => (item.valueStore === relatedValueStore));\r\n        if (index < 0) {\r\n            this.arrCleanedUpRelated = (this.arrCleanedUpRelated || []).concat([{ msg: msg, valueStore: relatedValueStore }]);\r\n            return (() => { this.unlistenCleanedUpRelated(relatedValueStore); });\r\n        }\r\n        else {\r\n            return (() => { });\r\n        }\r\n    }\r\n    /**\r\n     * unregister the relatedValueStore\r\n     * @param relatedValueStore\r\n     */\r\n    unlistenCleanedUpRelated(relatedValueStore) {\r\n        if (this.arrCleanedUpRelated !== undefined) {\r\n            this.arrCleanedUpRelated = this.arrCleanedUpRelated.filter((item) => (item.valueStore !== relatedValueStore));\r\n            if (this.arrCleanedUpRelated.length === 0) {\r\n                this.arrCleanedUpRelated = undefined;\r\n            }\r\n        }\r\n    }\r\n    emitUIUpdate(uiStateValue) {\r\n        if (this.storeManager === undefined) {\r\n            uiStateValue.triggerUIUpdate(this.stateVersion);\r\n        }\r\n        else {\r\n            if ((this._ViewProps !== undefined) && !this.triggerUIUpdate) {\r\n                this.storeManager.emitUIUpdate(this);\r\n            }\r\n            this.storeManager.emitUIUpdate(uiStateValue);\r\n        }\r\n    }\r\n    triggerUIUpdate(stateVersion) {\r\n        this.triggerScheduled = false;\r\n        // const stateVersion = this.stateValue.stateVersion;\r\n        // if (this.component === undefined) {\r\n        //     //\r\n        // } else {\r\n        //     if (stateVersion === this.viewStateVersion) {\r\n        //         //\r\n        //         dsLog.info(`DSUIStateValue skip update same stateVersion: ${stateVersion}`)\r\n        //     } else {\r\n        this.viewStateVersion = stateVersion;\r\n        const enabled = (_DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.enabled && _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.isEnabled(\"triggerUIUpdate\"));\r\n        if (this.arrComponentStateVersionName === undefined) {\r\n            //\r\n        }\r\n        else if (Array.isArray(this.arrComponentStateVersionName)) {\r\n            for (const componentStateVersionName of this.arrComponentStateVersionName) {\r\n                componentStateVersionName.component.setState({ [componentStateVersionName.stateVersionName]: stateVersion });\r\n                if (enabled) {\r\n                    _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSUIStateValue\", \"triggerUIUpdate\", _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.convertArg(componentStateVersionName));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.arrComponentStateVersionName.component.setState({ [this.arrComponentStateVersionName.stateVersionName]: stateVersion });\r\n            if (enabled) {\r\n                _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.infoACME(\"DS\", \"DSUIStateValue\", \"triggerUIUpdate\", _DSLog__WEBPACK_IMPORTED_MODULE_0__.dsLog.convertArg(this.arrComponentStateVersionName));\r\n            }\r\n        }\r\n        //     }\r\n        // }\r\n    }\r\n    getViewProps() {\r\n        if (this._ViewProps === undefined) {\r\n            const fnGetRenderProps = (() => {\r\n                return this;\r\n            });\r\n            const fnWireStateVersion = ((component, stateVersionName) => {\r\n                const csvn = { component: component, stateVersionName: stateVersionName ?? \"stateVersion\" };\r\n                if (this.arrComponentStateVersionName === undefined) {\r\n                    this.arrComponentStateVersionName = csvn;\r\n                }\r\n                else if (Array.isArray(this.arrComponentStateVersionName)) {\r\n                    this.arrComponentStateVersionName.push(csvn);\r\n                }\r\n                else {\r\n                    this.arrComponentStateVersionName = [this.arrComponentStateVersionName, csvn];\r\n                }\r\n                return this.stateVersion;\r\n            });\r\n            const fnUnwireStateVersion = ((component) => {\r\n                if (this.arrComponentStateVersionName === undefined) {\r\n                    // done\r\n                }\r\n                else if (Array.isArray(this.arrComponentStateVersionName)) {\r\n                    for (let idx = 0; idx < this.arrComponentStateVersionName.length; idx++) {\r\n                        if (this.arrComponentStateVersionName[idx].component === component) {\r\n                            this.arrComponentStateVersionName.splice(idx, 1);\r\n                            if (this.arrComponentStateVersionName.length === 1) {\r\n                                this.arrComponentStateVersionName = this.arrComponentStateVersionName[0];\r\n                            }\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (this.arrComponentStateVersionName.component === component) {\r\n                        this.arrComponentStateVersionName = undefined;\r\n                    }\r\n                }\r\n            });\r\n            const fnGetStateVersion = (() => {\r\n                return this.stateVersion;\r\n            });\r\n            //\r\n            this._ViewProps = {\r\n                getRenderProps: fnGetRenderProps,\r\n                wireStateVersion: fnWireStateVersion,\r\n                unwireStateVersion: fnUnwireStateVersion,\r\n                getStateVersion: fnGetStateVersion,\r\n            };\r\n        }\r\n        return this._ViewProps;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/DSValueStore.ts?");

/***/ }),

/***/ "./libs/dependingState/src/PromiseHelper.ts":
/*!**************************************************!*\
  !*** ./libs/dependingState/src/PromiseHelper.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"catchLog\": () => (/* binding */ catchLog),\n/* harmony export */   \"handleDSEventHandlerResult\": () => (/* binding */ handleDSEventHandlerResult)\n/* harmony export */ });\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! . */ \"./libs/dependingState/src/index.ts\");\n\r\nfunction catchLog(msg, promise) {\r\n    return promise.then((v) => {\r\n        return v;\r\n    }, (reason) => {\r\n        // console.error(msg, reason);\r\n        ___WEBPACK_IMPORTED_MODULE_0__.dsLog.errorACME(\"DS\", \"handleDSEventHandlerResult\", msg, reason);\r\n        return undefined;\r\n    });\r\n}\r\nfunction handleDSEventHandlerResult(msg, p) {\r\n    if (p && (typeof p.then === \"function\")) {\r\n        return p.then((v) => {\r\n            return v;\r\n        }, (reason) => {\r\n            // console.error(msg, reason);\r\n            ___WEBPACK_IMPORTED_MODULE_0__.dsLog.errorACME(\"DS\", \"handleDSEventHandlerResult\", msg, reason);\r\n            return undefined;\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/PromiseHelper.ts?");

/***/ }),

/***/ "./libs/dependingState/src/index.ts":
/*!******************************************!*\
  !*** ./libs/dependingState/src/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DSArrayStore\": () => (/* reexport safe */ _DSArrayStore__WEBPACK_IMPORTED_MODULE_2__.DSArrayStore),\n/* harmony export */   \"DSEntityStore\": () => (/* reexport safe */ _DSEntityStore__WEBPACK_IMPORTED_MODULE_4__.DSEntityStore),\n/* harmony export */   \"DSLog\": () => (/* reexport safe */ _DSLog__WEBPACK_IMPORTED_MODULE_5__.DSLog),\n/* harmony export */   \"DSLogACME\": () => (/* reexport safe */ _DSLog__WEBPACK_IMPORTED_MODULE_5__.DSLogACME),\n/* harmony export */   \"DSLogBase\": () => (/* reexport safe */ _DSLog__WEBPACK_IMPORTED_MODULE_5__.DSLogBase),\n/* harmony export */   \"DSLooseStore\": () => (/* reexport safe */ _DSLooseStore__WEBPACK_IMPORTED_MODULE_6__.DSLooseStore),\n/* harmony export */   \"DSMapStore\": () => (/* reexport safe */ _DSMapStore__WEBPACK_IMPORTED_MODULE_7__.DSMapStore),\n/* harmony export */   \"DSObjectStore\": () => (/* reexport safe */ _DSObjectStore__WEBPACK_IMPORTED_MODULE_8__.DSObjectStore),\n/* harmony export */   \"DSPropertiesChanged\": () => (/* reexport safe */ _DSPropertiesChanged__WEBPACK_IMPORTED_MODULE_9__.DSPropertiesChanged),\n/* harmony export */   \"DSStateValue\": () => (/* reexport safe */ _DSStateValue__WEBPACK_IMPORTED_MODULE_10__.DSStateValue),\n/* harmony export */   \"DSStateValueSelf\": () => (/* reexport safe */ _DSStateValueSelf__WEBPACK_IMPORTED_MODULE_11__.DSStateValueSelf),\n/* harmony export */   \"DSStoreAction\": () => (/* reexport safe */ _DSStoreBuilder__WEBPACK_IMPORTED_MODULE_12__.DSStoreAction),\n/* harmony export */   \"DSStoreBuilder\": () => (/* reexport safe */ _DSStoreBuilder__WEBPACK_IMPORTED_MODULE_12__.DSStoreBuilder),\n/* harmony export */   \"DSStoreManager\": () => (/* reexport safe */ _DSStoreManager__WEBPACK_IMPORTED_MODULE_18__.DSStoreManager),\n/* harmony export */   \"DSUIBinder\": () => (/* reexport safe */ _DSUIBinder__WEBPACK_IMPORTED_MODULE_14__.DSUIBinder),\n/* harmony export */   \"DSUIStateValue\": () => (/* reexport safe */ _DSUIStateValue__WEBPACK_IMPORTED_MODULE_13__.DSUIStateValue),\n/* harmony export */   \"DSValueChanged\": () => (/* reexport safe */ _DSValueChanged__WEBPACK_IMPORTED_MODULE_15__.DSValueChanged),\n/* harmony export */   \"DSValueStore\": () => (/* reexport safe */ _DSValueStore__WEBPACK_IMPORTED_MODULE_16__.DSValueStore),\n/* harmony export */   \"bindUIComponent\": () => (/* reexport safe */ _DSUIBinder__WEBPACK_IMPORTED_MODULE_14__.bindUIComponent),\n/* harmony export */   \"catchLog\": () => (/* reexport safe */ _PromiseHelper__WEBPACK_IMPORTED_MODULE_17__.catchLog),\n/* harmony export */   \"deepEquals\": () => (/* reexport safe */ _DSDeepEquals__WEBPACK_IMPORTED_MODULE_3__.deepEquals),\n/* harmony export */   \"defaultConvertExtraArg\": () => (/* reexport safe */ _DSLog__WEBPACK_IMPORTED_MODULE_5__.defaultConvertExtraArg),\n/* harmony export */   \"dsIsArrayEqual\": () => (/* reexport safe */ _DSArrayHelper__WEBPACK_IMPORTED_MODULE_1__.dsIsArrayEqual),\n/* harmony export */   \"dsLog\": () => (/* reexport safe */ _DSLog__WEBPACK_IMPORTED_MODULE_5__.dsLog),\n/* harmony export */   \"getPropertiesChanged\": () => (/* reexport safe */ _DSPropertiesChanged__WEBPACK_IMPORTED_MODULE_9__.getPropertiesChanged),\n/* harmony export */   \"getPropertiesSet\": () => (/* reexport safe */ _DSPropertiesChanged__WEBPACK_IMPORTED_MODULE_9__.getPropertiesSet),\n/* harmony export */   \"handleDSEventHandlerResult\": () => (/* reexport safe */ _PromiseHelper__WEBPACK_IMPORTED_MODULE_17__.handleDSEventHandlerResult),\n/* harmony export */   \"hasChangedProperty\": () => (/* reexport safe */ _DSPropertiesChanged__WEBPACK_IMPORTED_MODULE_9__.hasChangedProperty),\n/* harmony export */   \"stateValue\": () => (/* reexport safe */ _DSStateValue__WEBPACK_IMPORTED_MODULE_10__.stateValue),\n/* harmony export */   \"storeBuilder\": () => (/* reexport safe */ _DSStoreBuilder__WEBPACK_IMPORTED_MODULE_12__.storeBuilder)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./libs/dependingState/src/types.ts\");\n/* harmony import */ var _DSArrayHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DSArrayHelper */ \"./libs/dependingState/src/DSArrayHelper.ts\");\n/* harmony import */ var _DSArrayStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DSArrayStore */ \"./libs/dependingState/src/DSArrayStore.ts\");\n/* harmony import */ var _DSDeepEquals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DSDeepEquals */ \"./libs/dependingState/src/DSDeepEquals.ts\");\n/* harmony import */ var _DSEntityStore__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DSEntityStore */ \"./libs/dependingState/src/DSEntityStore.ts\");\n/* harmony import */ var _DSLog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DSLog */ \"./libs/dependingState/src/DSLog.ts\");\n/* harmony import */ var _DSLooseStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DSLooseStore */ \"./libs/dependingState/src/DSLooseStore.ts\");\n/* harmony import */ var _DSMapStore__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DSMapStore */ \"./libs/dependingState/src/DSMapStore.ts\");\n/* harmony import */ var _DSObjectStore__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DSObjectStore */ \"./libs/dependingState/src/DSObjectStore.ts\");\n/* harmony import */ var _DSPropertiesChanged__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DSPropertiesChanged */ \"./libs/dependingState/src/DSPropertiesChanged.ts\");\n/* harmony import */ var _DSStateValue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DSStateValue */ \"./libs/dependingState/src/DSStateValue.ts\");\n/* harmony import */ var _DSStateValueSelf__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./DSStateValueSelf */ \"./libs/dependingState/src/DSStateValueSelf.ts\");\n/* harmony import */ var _DSStoreBuilder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./DSStoreBuilder */ \"./libs/dependingState/src/DSStoreBuilder.ts\");\n/* harmony import */ var _DSUIStateValue__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./DSUIStateValue */ \"./libs/dependingState/src/DSUIStateValue.ts\");\n/* harmony import */ var _DSUIBinder__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./DSUIBinder */ \"./libs/dependingState/src/DSUIBinder.ts\");\n/* harmony import */ var _DSValueChanged__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./DSValueChanged */ \"./libs/dependingState/src/DSValueChanged.ts\");\n/* harmony import */ var _DSValueStore__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./DSValueStore */ \"./libs/dependingState/src/DSValueStore.ts\");\n/* harmony import */ var _PromiseHelper__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./PromiseHelper */ \"./libs/dependingState/src/PromiseHelper.ts\");\n/* harmony import */ var _DSStoreManager__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./DSStoreManager */ \"./libs/dependingState/src/DSStoreManager.ts\");\n\r\n//     DSPayloadEntitySV as DSPayloadEntity,\r\n//     DSEventEntityVSAttach as DSEventAttach,\r\n//     DSEventEntitySVDetach as DSEventDetach,\r\n//     DSPayloadEntitySVValue as DSPayloadEntityPropertiesChanged,\r\n//     DSEventEntityVSValue as DSEventValue,\r\n//     DSEmitDirtyValueHandler as DSDirtyHandler,\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/index.ts?");

/***/ }),

/***/ "./libs/dependingState/src/types.ts":
/*!******************************************!*\
  !*** ./libs/dependingState/src/types.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\r\n\n\n//# sourceURL=webpack://app/./libs/dependingState/src/types.ts?");

/***/ }),

/***/ "./src/components/AppUI/AppUIActions.ts":
/*!**********************************************!*\
  !*** ./src/components/AppUI/AppUIActions.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"appUIStoreBuilder\": () => (/* binding */ appUIStoreBuilder),\n/* harmony export */   \"loadData\": () => (/* binding */ loadData)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n\r\nconst appUIStoreBuilder = (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.storeBuilder)(\"AppUIStore\");\r\nconst loadData = appUIStoreBuilder.createAction(\"loadData\");\r\n\n\n//# sourceURL=webpack://app/./src/components/AppUI/AppUIActions.ts?");

/***/ }),

/***/ "./src/components/AppUI/AppUIStore.ts":
/*!********************************************!*\
  !*** ./src/components/AppUI/AppUIStore.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AppUIStore\": () => (/* binding */ AppUIStore)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n/* harmony import */ var _AppUIActions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AppUIActions */ \"./src/components/AppUI/AppUIActions.ts\");\n/* harmony import */ var _singletonAppStoreManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ~/singletonAppStoreManager */ \"./src/singletonAppStoreManager.ts\");\n\r\n// import type { IAppStoreManager } from \"~/services/AppStoreManager\";\r\n\r\n\r\nclass AppUIStore extends dependingState__WEBPACK_IMPORTED_MODULE_0__.DSObjectStore {\r\n    constructor(value) {\r\n        super(\"AppUIStore\", value);\r\n        _AppUIActions__WEBPACK_IMPORTED_MODULE_1__.appUIStoreBuilder.bindValueStore(this);\r\n    }\r\n    initializeStore() {\r\n        super.initializeStore();\r\n        _AppUIActions__WEBPACK_IMPORTED_MODULE_1__.loadData.listenEvent(\"TODO\", (e) => {\r\n        });\r\n        const navigatorStore = (0,_singletonAppStoreManager__WEBPACK_IMPORTED_MODULE_2__.getAppStoreManager)().navigatorStore;\r\n        navigatorStore.listenValueChanged(\"AppUIStore listen to router\", (stateValue, properties) => {\r\n            if ((0,dependingState__WEBPACK_IMPORTED_MODULE_0__.hasChangedProperty)(properties, \"page\")) {\r\n                this.stateValue.emitUIUpdate();\r\n            }\r\n        });\r\n        // this.isDirty=true;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./src/components/AppUI/AppUIStore.ts?");

/***/ }),

/***/ "./src/components/AppUI/AppUIValue.ts":
/*!********************************************!*\
  !*** ./src/components/AppUI/AppUIValue.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AppUIValue\": () => (/* binding */ AppUIValue)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n\r\nclass AppUIValue extends dependingState__WEBPACK_IMPORTED_MODULE_0__.DSStateValueSelf {\r\n    constructor() {\r\n        super();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./src/components/AppUI/AppUIValue.ts?");

/***/ }),

/***/ "./src/components/AppUI/AppUIView.tsx":
/*!********************************************!*\
  !*** ./src/components/AppUI/AppUIView.tsx ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"appUIView\": () => (/* binding */ appUIView),\n/* harmony export */   \"default\": () => (/* binding */ AppUIView)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\r\n/**\r\n * create a new AppUIView\r\n * @param props stateValue.getViewProps()\r\n */\r\nfunction appUIView(props) {\r\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(AppUIView, props);\r\n}\r\nclass AppUIView extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            stateVersion: this.props.getStateVersion()\r\n        };\r\n        this.props.wireStateVersion(this);\r\n        this.handleClick = this.handleClick.bind(this);\r\n    }\r\n    componentWillUnmount() {\r\n        this.props.unwireStateVersion(this);\r\n    }\r\n    handleClick() {\r\n    }\r\n    render() {\r\n        const renderProps = this.props.getRenderProps();\r\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null,\r\n            \"App\",\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null,\r\n                \"AppUI - StateVersion: \",\r\n                this.props.getStateVersion(),\r\n                \" - dt:\",\r\n                (new Date()).toISOString()),\r\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null,\r\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { onClick: this.handleClick }, \"doSomething\"))));\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./src/components/AppUI/AppUIView.tsx?");

/***/ }),

/***/ "./src/components/Navigator/NavigatorStore.ts":
/*!****************************************************!*\
  !*** ./src/components/Navigator/NavigatorStore.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NavigatorStore\": () => (/* binding */ NavigatorStore)\n/* harmony export */ });\n/* harmony import */ var dependingStateRouter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingStateRouter */ \"./libs/dependingStateRouter/src/index.ts\");\n\r\nclass NavigatorStore extends dependingStateRouter__WEBPACK_IMPORTED_MODULE_0__.DSNavigatorStore {\r\n    constructor(stateValue, configuration) {\r\n        super(\"navigator\", stateValue, configuration);\r\n        this.pathNames = [\"home\", \"pageA\", \"pageB\"];\r\n        const path = this.path = {\r\n            home: \"/\",\r\n            pageA: \"/pageA\",\r\n            pageB: [\"/pageB\", \"/pageB/:id\"],\r\n        };\r\n        this.patterns = {\r\n            home: path.home,\r\n            pageA: path.pageA,\r\n            pageB: path.pageB[1],\r\n        };\r\n        this.route = {\r\n            home: {\r\n                path: this.path.home,\r\n                exact: true\r\n            },\r\n            pageA: {\r\n                path: this.path.pageA\r\n            },\r\n            pageB: {\r\n                path: this.path.pageB\r\n            },\r\n        };\r\n        this.pages = {\r\n            \"home\": \"home\",\r\n            \"pageA\": \"pageA\",\r\n            \"pageB\": \"pageB\",\r\n        };\r\n    }\r\n    /** called if push or replace was called */\r\n    handleLocationChanged(payload) {\r\n        const { action, location, updateMode } = payload;\r\n        {\r\n            const result = this.matchPaths(location);\r\n            if (result !== null) {\r\n                const [pathName, m] = result;\r\n                /*\r\n                if (pathName===\"pageB\")\r\n                */\r\n                this.stateValue.value = {\r\n                    page: this.pages[pathName],\r\n                    pathArguments: m.params,\r\n                    //isExact: m.isExact,\r\n                    //pathName: pathName\r\n                };\r\n            }\r\n            else {\r\n                this.stateValue.value = {\r\n                    page: \"pageError\",\r\n                    pathArguments: {},\r\n                    //isExact: false,\r\n                    //pathName: \"\"\r\n                };\r\n            }\r\n        }\r\n    }\r\n    matchPaths(location) {\r\n        for (const pathName of this.pathNames) {\r\n            const m = this.matchPath(location.pathname, this.route[pathName]);\r\n            if (m) {\r\n                return [pathName, m];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    convertTo(payload) {\r\n        // payload.page\r\n        return payload;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./src/components/Navigator/NavigatorStore.ts?");

/***/ }),

/***/ "./src/components/PageA/PageAActions.ts":
/*!**********************************************!*\
  !*** ./src/components/PageA/PageAActions.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"doSomething\": () => (/* binding */ doSomething),\n/* harmony export */   \"pageAStoreBuilder\": () => (/* binding */ pageAStoreBuilder)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n\r\n//\r\nconst pageAStoreBuilder = (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.storeBuilder)(\"PageAStore\");\r\nconst doSomething = pageAStoreBuilder.createAction(\"DoSomething\");\r\n//\r\n\n\n//# sourceURL=webpack://app/./src/components/PageA/PageAActions.ts?");

/***/ }),

/***/ "./src/components/PageA/PageAStore.ts":
/*!********************************************!*\
  !*** ./src/components/PageA/PageAStore.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PageAStore\": () => (/* binding */ PageAStore)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n/* harmony import */ var _PageAActions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PageAActions */ \"./src/components/PageA/PageAActions.ts\");\n/* harmony import */ var _PageAValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PageAValue */ \"./src/components/PageA/PageAValue.ts\");\n\r\n\r\n\r\nclass PageAStore extends dependingState__WEBPACK_IMPORTED_MODULE_0__.DSObjectStore {\r\n    constructor() {\r\n        super(\"PageAStore\", new _PageAValue__WEBPACK_IMPORTED_MODULE_2__.PageAValue());\r\n        this.setStoreBuilder(_PageAActions__WEBPACK_IMPORTED_MODULE_1__.pageAStoreBuilder);\r\n    }\r\n    initializeStore() {\r\n        _PageAActions__WEBPACK_IMPORTED_MODULE_1__.doSomething.listenEvent(\"handle doSomething\", (e) => {\r\n            const stateValuePC = (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.getPropertiesChanged)(this.stateValue);\r\n            stateValuePC.setIf(\"myPropA\", \"Hello World\");\r\n            stateValuePC.valueChangedIfNeeded(\"\");\r\n        });\r\n        this.listenEventValue(\"listen for myPropA\", (e) => {\r\n            const properties = e.payload.properties;\r\n            if ((0,dependingState__WEBPACK_IMPORTED_MODULE_0__.hasChangedProperty)(properties, \"myPropA\")) {\r\n                const entityVS = e.payload.entity;\r\n                const myPropA = entityVS.value.myPropA;\r\n                const pageAValuePC = (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.getPropertiesChanged)(entityVS);\r\n                pageAValuePC.setIf(\"myPropB\", `${myPropA}::${myPropA}`);\r\n                pageAValuePC.valueChangedIfNeeded(\"\");\r\n            }\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./src/components/PageA/PageAStore.ts?");

/***/ }),

/***/ "./src/components/PageA/PageAValue.ts":
/*!********************************************!*\
  !*** ./src/components/PageA/PageAValue.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PageAValue\": () => (/* binding */ PageAValue)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n\r\nclass PageAValue extends dependingState__WEBPACK_IMPORTED_MODULE_0__.DSStateValueSelf {\r\n    constructor() {\r\n        super();\r\n        this.myPropA = \"\";\r\n        this.myPropB = \"\";\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./src/components/PageA/PageAValue.ts?");

/***/ }),

/***/ "./src/components/PageB/PageBActions.ts":
/*!**********************************************!*\
  !*** ./src/components/PageB/PageBActions.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"doSomething\": () => (/* binding */ doSomething),\n/* harmony export */   \"pageBStoreBuilder\": () => (/* binding */ pageBStoreBuilder)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n\r\n//\r\nconst pageBStoreBuilder = (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.storeBuilder)(\"PageBStore\");\r\nconst doSomething = pageBStoreBuilder.createAction(\"DoSomething\");\r\n//\r\n\n\n//# sourceURL=webpack://app/./src/components/PageB/PageBActions.ts?");

/***/ }),

/***/ "./src/components/PageB/PageBStore.ts":
/*!********************************************!*\
  !*** ./src/components/PageB/PageBStore.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PageBStore\": () => (/* binding */ PageBStore)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n/* harmony import */ var _PageBActions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PageBActions */ \"./src/components/PageB/PageBActions.ts\");\n/* harmony import */ var _PageBValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PageBValue */ \"./src/components/PageB/PageBValue.ts\");\n\r\n\r\n\r\nclass PageBStore extends dependingState__WEBPACK_IMPORTED_MODULE_0__.DSObjectStore {\r\n    constructor() {\r\n        super(\"PageBStore\", new _PageBValue__WEBPACK_IMPORTED_MODULE_2__.PageBValue());\r\n        this.setStoreBuilder(_PageBActions__WEBPACK_IMPORTED_MODULE_1__.pageBStoreBuilder);\r\n    }\r\n    initializeStore() {\r\n        _PageBActions__WEBPACK_IMPORTED_MODULE_1__.doSomething.listenEvent(\"handle doSomething\", (e) => {\r\n            const stateValuePC = (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.getPropertiesChanged)(this.stateValue);\r\n            stateValuePC.setIf(\"myPropA\", \"Hello World\");\r\n            stateValuePC.valueChangedIfNeeded(\"\");\r\n        });\r\n        this.listenEventValue(\"listen for myPropA\", (e) => {\r\n            const properties = e.payload.properties;\r\n            if ((0,dependingState__WEBPACK_IMPORTED_MODULE_0__.hasChangedProperty)(properties, \"myPropA\")) {\r\n                const entityVS = e.payload.entity;\r\n                const myPropA = entityVS.value.myPropA;\r\n                const pageAValuePC = (0,dependingState__WEBPACK_IMPORTED_MODULE_0__.getPropertiesChanged)(entityVS);\r\n                pageAValuePC.setIf(\"myPropB\", `${myPropA}::${myPropA}`);\r\n                pageAValuePC.valueChangedIfNeeded(\"\");\r\n            }\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./src/components/PageB/PageBStore.ts?");

/***/ }),

/***/ "./src/components/PageB/PageBValue.ts":
/*!********************************************!*\
  !*** ./src/components/PageB/PageBValue.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PageBValue\": () => (/* binding */ PageBValue)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n\r\nclass PageBValue extends dependingState__WEBPACK_IMPORTED_MODULE_0__.DSStateValueSelf {\r\n    constructor() {\r\n        super();\r\n        this.myPropA = \"\";\r\n        this.myPropB = \"\";\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./src/components/PageB/PageBValue.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n/* harmony import */ var _components_AppUI_AppUIView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/AppUI/AppUIView */ \"./src/components/AppUI/AppUIView.tsx\");\n/* harmony import */ var _services_AppStoreManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./services/AppStoreManager */ \"./src/services/AppStoreManager.ts\");\n/* harmony import */ var _singletonAppStoreManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./singletonAppStoreManager */ \"./src/singletonAppStoreManager.ts\");\n/* harmony import */ var _components_PageA_PageAStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/PageA/PageAStore */ \"./src/components/PageA/PageAStore.ts\");\n/* harmony import */ var _components_AppUI_AppUIValue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/AppUI/AppUIValue */ \"./src/components/AppUI/AppUIValue.ts\");\n/* harmony import */ var _components_AppUI_AppUIStore__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/AppUI/AppUIStore */ \"./src/components/AppUI/AppUIStore.ts\");\n/* harmony import */ var _components_PageB_PageBStore__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/PageB/PageBStore */ \"./src/components/PageB/PageBStore.ts\");\n/* harmony import */ var dependingStateRouter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! dependingStateRouter */ \"./libs/dependingStateRouter/src/index.ts\");\n/* harmony import */ var _components_Navigator_NavigatorStore__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/Navigator/NavigatorStore */ \"./src/components/Navigator/NavigatorStore.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction main() {\r\n    // initialize log\r\n    dependingState__WEBPACK_IMPORTED_MODULE_2__.dsLog.initialize();\r\n    // remove this if going productive\r\n    dependingState__WEBPACK_IMPORTED_MODULE_2__.dsLog.setEnabled();\r\n    if (dependingState__WEBPACK_IMPORTED_MODULE_2__.dsLog.enabled) {\r\n        dependingState__WEBPACK_IMPORTED_MODULE_2__.dsLog.info(\"Abc main()\");\r\n    }\r\n    // create all stores\r\n    const routerStore = new dependingStateRouter__WEBPACK_IMPORTED_MODULE_10__.DSRouterStore((0,dependingStateRouter__WEBPACK_IMPORTED_MODULE_10__.createBrowserHistory)(), (0,dependingStateRouter__WEBPACK_IMPORTED_MODULE_10__.getDSRouterValueInitial)());\r\n    const navigatorStore = new _components_Navigator_NavigatorStore__WEBPACK_IMPORTED_MODULE_11__.NavigatorStore(new dependingState__WEBPACK_IMPORTED_MODULE_2__.DSStateValue({ page: \"home\", pathArguments: {} }));\r\n    navigatorStore.setRouter(routerStore);\r\n    const pageAStore = new _components_PageA_PageAStore__WEBPACK_IMPORTED_MODULE_6__.PageAStore();\r\n    const pageBStore = new _components_PageB_PageBStore__WEBPACK_IMPORTED_MODULE_9__.PageBStore();\r\n    const appUIStore = new _components_AppUI_AppUIStore__WEBPACK_IMPORTED_MODULE_8__.AppUIStore(new _components_AppUI_AppUIValue__WEBPACK_IMPORTED_MODULE_7__.AppUIValue());\r\n    // create appStoreManager\r\n    const appStoreManager = new _services_AppStoreManager__WEBPACK_IMPORTED_MODULE_4__.AppStoreManager(routerStore, navigatorStore, appUIStore, pageAStore, pageBStore);\r\n    (0,_singletonAppStoreManager__WEBPACK_IMPORTED_MODULE_5__.setAppStoreManager)(appStoreManager);\r\n    dependingState__WEBPACK_IMPORTED_MODULE_2__.dsLog.attach(appStoreManager);\r\n    appStoreManager.initialize();\r\n    // start React\r\n    const rootElement = react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_AppUI_AppUIView__WEBPACK_IMPORTED_MODULE_3__[\"default\"], appStoreManager.appUIStore.stateValue.getViewProps());\r\n    const appRootElement = window.document.getElementById(\"appRoot\");\r\n    if (appRootElement) {\r\n        react_dom__WEBPACK_IMPORTED_MODULE_1__.render(rootElement, appRootElement);\r\n    }\r\n    else {\r\n        console.error(\"'appRoot' not defined.\");\r\n    }\r\n}\r\ntry {\r\n    main();\r\n}\r\ncatch (err) {\r\n    console.error(\"Error while app boots.\", err);\r\n}\r\n\n\n//# sourceURL=webpack://app/./src/index.ts?");

/***/ }),

/***/ "./src/services/AppStoreManager.ts":
/*!*****************************************!*\
  !*** ./src/services/AppStoreManager.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AppStoreManager\": () => (/* binding */ AppStoreManager)\n/* harmony export */ });\n/* harmony import */ var dependingState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dependingState */ \"./libs/dependingState/src/index.ts\");\n\r\nclass AppStoreManager extends dependingState__WEBPACK_IMPORTED_MODULE_0__.DSStoreManager {\r\n    constructor(routerStore, navigatorStore, appUIStore, pageAStore, pageBStore) {\r\n        super();\r\n        this.routerStore = routerStore;\r\n        this.navigatorStore = navigatorStore;\r\n        this.appUIStore = appUIStore;\r\n        this.pageAStore = pageAStore;\r\n        this.pageBStore = pageBStore;\r\n        this.attach(routerStore);\r\n        this.attach(navigatorStore);\r\n        this.attach(appUIStore);\r\n        this.attach(pageAStore);\r\n        this.attach(pageBStore);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://app/./src/services/AppStoreManager.ts?");

/***/ }),

/***/ "./src/singletonAppStoreManager.ts":
/*!*****************************************!*\
  !*** ./src/singletonAppStoreManager.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getAppStoreManager\": () => (/* binding */ getAppStoreManager),\n/* harmony export */   \"setAppStoreManager\": () => (/* binding */ setAppStoreManager)\n/* harmony export */ });\nvar appStoreManager;\r\nfunction setAppStoreManager(v) {\r\n    appStoreManager = v;\r\n}\r\nfunction getAppStoreManager() {\r\n    return appStoreManager;\r\n}\r\n\n\n//# sourceURL=webpack://app/./src/singletonAppStoreManager.ts?");

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["npm.scheduler","npm.react","npm.react-dom","npm.path-to-regexp","npm.object-assign"], () => (__webpack_exec__("./src/index.ts")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ }
]);